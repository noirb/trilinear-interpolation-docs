<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>NB Trilinear Mesh Interpolation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NB Trilinear Mesh Interpolation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="usage--examples"><a class="header" href="#usage--examples">Usage &amp; Examples</a></h1>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<p>The basic idea behind Trilinear Mesh Interpolation is this: enclose your mesh in a box (typically referred to here as the <code>Lattice</code>). The default state of the
box essentially matches the mesh's bounding box. When the corners of the box are moved, the mesh deforms to move with it, with vertices close to the moved corner
moving about the same as the corner and vertices far from the moved corner not being affected at all. Vertices will always move to maintain their position within
the lattice, relative to each corner.</p>
<p>Lattice values are treated as offsets. If the lattice corners all have the value <code>(0,0,0)</code>, then the mesh will be untransformed and will appear in its original state.</p>
<h2 id="two-approaches-to-interpolation"><a class="header" href="#two-approaches-to-interpolation">Two Approaches to Interpolation</a></h2>
<p>This plugin provides two approaches to trilinear interpolation. Visually, they will produce the same results, but which approach you should prefer to use may
depend on your use case.</p>
<h3 id="wpo-based-material-shader"><a class="header" href="#wpo-based-material-shader"><a href="how-to/./trilerp-materials.html">WPO-Based Material Shader</a></a></h3>
<p>The trilinear interpolation can be performed entirely in a shader, allowing for the effect to be performed on the GPU.</p>
<p>This is very fast, and can be used on meshes with a high vertex count and can support a large number of meshes all deforming together in a scene at real-time.
However, the effect is purely visual, the collision geometry of the mesh, etc., is unchanged.</p>
<p>If you need to animate the effect, particularly if you need a LOT of objects all bouncing and twisting around in a scene together, this is the recommended approach.</p>
<p>If you just need to apply the effect once, for example in-editor or during a procedural level generation step, or if you need collision geometry to match the
deformed mesh, then you should use the DynamicMesh-based approach.</p>
<h3 id="dynamicmesh"><a class="header" href="#dynamicmesh"><a href="how-to/./trilerp-mesh.html">DynamicMesh</a></a></h3>
<p>In this approach, the trilinear interpolation is performed on the CPU to modify a given mesh. The underlying C++ code has been optimized to parallelize this work
where possible, so you can still use this to perform real-time deformation on detailed meshes or on a number of simple meshes in a scene, but performance will be
limited by the total number of vertices you need to process in a given frame.</p>
<p>But, because we are processing the mesh data on the CPU we can also process a mesh's <em>collision</em> data, so you can use this to tweak the angle of a slope and then
have your character walk on it.</p>
<p>This approach is best used sparingly or on meshes which only need to be deformed once (e.g. in-editor or as part of a procedural level generation step).</p>
<h1 id="pages"><a class="header" href="#pages">Pages</a></h1>
<ul>
<li><a href="how-to//trilinear-interpolation-docs/how-to/trilerp-materials.html">Trilinear Interpolation Materials</a></li>
<li><a href="how-to//trilinear-interpolation-docs/how-to/trilerp-mesh.html">Trilinear Interpolated Dynamic Meshes</a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trilinear-interpolation-materials"><a class="header" href="#trilinear-interpolation-materials">Trilinear Interpolation Materials</a></h1>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>The interpolation functionality is encapsulated in a single Material Function, which can be found under <code>NB - Interpolation &gt; Trilinear Interpolation</code></p>
<p><img src="how-to/../assets/tutorial/mf-trilerp-node.png" alt="" /></p>
<p>The Inputs are: A point or position you wish to transform (usually just the absolute world position), 8 <code>Cube_XX</code> values, which define the lattice offsets,
and the original (untransformed, scaled, or otherwise modified) bounds of the mesh you wish to transform.</p>
<p>It will output a <code>float3</code>, which can be directly used to drive the <code>World Position Offset</code> in your material.</p>
<p>The <code>Cube_XX</code> values refer to the corners of the lattice used to deform the mesh, with the first four values (<code>X0</code>)
defining the bottom four corners of the lattice and the last four (<code>X1</code>) defining the top four corners:</p>
<p><img src="how-to/../assets/tutorial/lattice-corners-shader.png" alt="" /></p>
<p>A complete example in which all interpolation values are driven by parameters (e.g. so you can manually adjust them in a blueprint):</p>
<p><img src="how-to/../assets/tutorial/trilerp-mat-example.png" alt="" /></p>
<p>Because we are using the <code>Absolute World Position</code> as the position to transform, we need to ensure that <code>MinBound</code> and <code>MaxBound</code> values are also in world coordinates.
This can be done easily using <code>Get Actor Bounds</code> in the blueprint passing this information to the material:
<img src="how-to/../assets/tutorial/trilerp-mat-example_bp-bounds.png" alt="" /></p>
<p>This is usually the most straightforward approach, but if for some reason you are not working in world coordinates it is important to remember that the bounds and the
point passed in for transformation must be in the same coordinate frame.</p>
<p>If you just intend to use the interpolation to make your object a little jiggly or bounce in response to some other material parameter, though, it's not necessary to expose
these values as parameters, you can drive them entirely within your material.</p>
<p>For example, the following material will move <strong>only</strong> the top of the lattice over time, causing the mesh to stretch up and down vertically. Because the bottom of the lattice is not
being changed, the base of the mesh will remain fixed in place, allowing for a bouncy animation without the mesh moving off of the ground. This allows you a lot of freedom to
stretch and twist the mesh as you want, while still being able to constrain it to keep one side fixed in place.</p>
<p><img src="how-to/../assets/tutorial/trilerp-mat-example_bounce.png" alt="" /></p>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<h3 id="bounds-scale"><a class="header" href="#bounds-scale">Bounds Scale</a></h3>
<p>If you use <code>World Position Offset</code> to create a large deformation in an object, this can lead to some very ugly shadow artifacts:
<img src="how-to/../assets/tutorial/wpo-bounds-scale-shadow-error.png" alt="" /></p>
<p>This can be fixed by increasing the bounds scale:
<img src="how-to/../assets/tutorial/wpo-bounds-scale-fix.png" alt="" /></p>
<p>But, depending on how you are computing the original mesh bounds you may notice that this changes the effect of the Trilinear interpolation!
(notice the bottom corners of the cube above are no longer correctly aligned with the ground)</p>
<p>If you are NOT passing the original (unscaled) object bounds as a material parameter but are relying on one of the <code>Object Bounds</code> or <code>Object Local Bounds</code> nodes, then you
will need to compensate for the bounds scale in the material. If you know you will always use a constant bounds scale you can use a constant value in the material,
or you can use a paramter to allow it to be set by an actor blueprint any time the bounds scale is changed or set to a fixed value in different material instances:</p>
<p><img src="how-to/../assets/tutorial/wpo-bounds-scale-fix-mat.png" alt="" />
In this example, we are using a parameter which is expected to be the <strong>inverse</strong> of the bounds scale, so if the bounds scale is set to <code>2.0</code> this parameter should be
set to <code>0.5</code>. This avoids the possibility of dividing by zero by mistake, but it would also work to use the bounds scale directly and replace the multiply node with
a divide.</p>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trilinear-interpolation-with-dynamicmesh"><a class="header" href="#trilinear-interpolation-with-dynamicmesh">Trilinear Interpolation With DynamicMesh</a></h1>
<p>Most of the functionality for deforming DynamicMeshes is contained within the <strong><code>UTrilerpMeshComponent</code></strong>.</p>
<h3 id="details"><a class="header" href="#details">Details:</a></h3>
<ul>
<li><a href="how-to/../blueprint-api/classes/TrilerpMeshComponent.html"><strong>Blueprint API</strong></a></li>
<li><a href="how-to/../reference/classes/UTrilerpMeshComponent.html"><strong>C++ API</strong></a></li>
</ul>
<p>However, it's not strictly necessary to use this component, you can implement your own components or logic using trilinear interpolation:</p>
<h3 id="details-1"><a class="header" href="#details-1">Details:</a></h3>
<ul>
<li><a href="how-to/../blueprint-api/functions/TrilinearInterpolationMesh.html"><strong>Blueprint</strong></a></li>
<li><a href="how-to/../reference/classes/UNBTrilinearInterpolation.html"><strong>C++</strong></a></li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>The easiest way to get up and running is to use the <code>TrilerpMeshComponent</code>. In the plugin's <code>Examples</code> directory, you will find a blueprint
called <code>BP_NBDynamicTrilerpMesh</code>, just set the <code>Source Mesh</code> property to the mesh you want to deform.</p>
<p>You can then either manipulate the lattice points directly:</p>
<p><img src="how-to/../assets/tutorial/set-lattice-val-update.png" alt="" /></p>
<p>or use one of the provided functions for manipulating sets of lattice points:</p>
<p><img src="how-to/../assets/tutorial/breathe-bp.png" alt="" /></p>
<p><img src="how-to/../assets/tutorial/breathe.gif" alt="" /></p>
<blockquote>
<p><code>TranslateFace</code>, <code>RotateFace</code>, and <code>ScaleFace</code> will all call <code>UpdateMesh</code> automatically. If you are manually updating individual lattice points,
you should call <code>UpdateMesh</code> yourself when you are finished to re-transform the mesh according to the new lattice points.</p>
</blockquote>
<h2 id="trilerpmeshcomponent-editor-tooling"><a class="header" href="#trilerpmeshcomponent-editor-tooling"><code>TrilerpMeshComponent</code> Editor Tooling</a></h2>
<p>If you select a <code>TrilerpMeshCompnent</code> in the editor, you will see a visualization of the current lattice state.</p>
<p>The green points represent the lattice points themselves, while the blue lines are just visual guides to help you see the shape of the lattice.</p>
<p><img src="how-to/../assets/tutorial/lattice-tools-1.png" alt="" /></p>
<p>Selecting one of the green points allows you to drag it around and directly modify the lattice:</p>
<p><img src="how-to/../assets/tutorial/lattice-face-drag.gif" alt="" /></p>
<p>If you select one of the grey points, this will select all of the points which make up one side of the lattice. This allows you not only to drag those
points together, but also allows you to use rotation and scaling tools on them:</p>
<p><img src="how-to/../assets/tutorial/lattice-face-rotate.gif" alt="" /></p>
<p><img src="how-to/../assets/tutorial/lattice-face-scale.gif" alt="" /></p>
<h2 id="handling-collision-data"><a class="header" href="#handling-collision-data">Handling Collision Data</a></h2>
<p>When initializing the <code>TrilerpMeshComponent</code> from a <strong>static mesh</strong> you have the option to copy <em>both</em> the visual mesh data as well as the collision data.
This allows us to automatically keep the collision data up-to-date with the mesh deformation.</p>
<h3 id="simple-collision"><a class="header" href="#simple-collision">Simple Collision</a></h3>
<p>If you enable <strong>Simple</strong> collision, then any time the mesh is updated we will automatically generate a new convex hull around the result.</p>
<p><img src="how-to/../assets/tutorial/simple-collision-editing.gif" alt="" /></p>
<p>If you find that this automatic convex hull doesn't fit your object well and do not wish to enable complex collision, then you can generate your own custom
collision shapes using the <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/GeometryScript/Collision/SetDynamicMeshCollisionfromMesh">Set Dynamic Mesh Collision from Mesh</a> node in
a blueprint, or <code>UGeometryScriptLibrary_CollisionFunctions::SetDynamicMeshCollisionFromMesh</code> (defined in <code>GeometryScript/CollisionFunctions.h</code>) in C++.</p>
<p>In this case, when initializing the <code>TrilerpMeshComponent</code> you should set <code>Include Collision</code> to <code>NONE</code>, otherwise every time you call <code>UpdateMesh</code> we will waste some CPU time processing unused collision geometry.</p>
<p><img src="how-to/../assets/tutorial/set-dynamic-collision-from-mesh.png" alt="" /></p>
<h3 id="complex-collision"><a class="header" href="#complex-collision">Complex Collision</a></h3>
<p>If you enable <strong>Complex</strong> collision, then the collision mesh, itself, will be deformed in the same way as the visual mesh. This means that any changes you make to the
mesh will be exactly reflected in the collision, although of course at added cost.</p>
<p><img src="how-to/../assets/tutorial/complex-collision-editing.gif" alt="" /></p>
<p>If this proves too expensive by default, an alternative approach would be to apply trilinear interpolation separately to two meshes, one detailed
mesh for visuals with no collision enabled, and one simple mesh with complex collision enabled that is not set to render. This can even be done without using multiple
<code>TrilerpMeshComponents</code> by transforming the extra mesh manually:</p>
<p><img src="how-to/../assets/tutorial/update-extra-mesh.png" alt="" /></p>
<blockquote>
<h4 id="note"><a class="header" href="#note">NOTE</a></h4>
<p>In order for complex collision to work correctly, make sure that it is enabled on the component:</p>
<p><img src="how-to/../assets/tutorial/enable-complex-collision.png" alt="" /></p>
</blockquote>
<h2 id="a-note-on-dynamicmeshactor"><a class="header" href="#a-note-on-dynamicmeshactor">A Note on DynamicMeshActor</a></h2>
<p>The <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/DynamicMeshActor">DynamicMeshActor</a> provides
a lot of additional functionality which is useful for working with DynamicMeshes. This functionality isn't required to use
the <code>TrilerpMeshComponent</code>, but if you are doing some of your own mesh modification/generation you may want to
use them together.</p>
<p>Fortunately, it is possible to replace the <code>DynamicMeshComponent</code> on a <code>DynamicMeshActor</code> with a <code>TrilerpMeshComponent</code>.
You can find the <code>Component Class</code> dropdown in the <code>DynamicMeshActor</code> details panel:
<img src="how-to/../assets/tutorial/dynamic-mesh-comp-type-setting.png" alt="" /></p>
<p>You then just need to cast to <code>TrilerpMeshComponent</code> in your actor blueprint:
<img src="how-to/../assets/tutorial/dynamic-mesh-comp-cast.png" alt="" /></p>
<p>The example blueprints are all configured this way.</p>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprint-api-documentation"><a class="header" href="#blueprint-api-documentation">Blueprint API Documentation</a></h1>
<p>An overview and explanation of all included Blueprint nodes</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h1 id="pages-1"><a class="header" href="#pages-1">Pages</a></h1>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pages-2"><a class="header" href="#pages-2">Pages</a></h1>
<ul>
<li><a href="blueprint-api/classes//trilinear-interpolation-docs/blueprint-api/classes/TrilerpMeshComponent.html">Trilerp Mesh Component</a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bp-class-trilerpmeshcomponent"><a class="header" href="#bp-class-trilerpmeshcomponent"><strong>BP Class: <code>TrilerpMeshComponent</code></strong></a></h1>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html"><code>UTrilerpMeshComponent</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
<p>A DynamicMeshComponent which supports trilinear interpolation of the underlying mesh.</p>
<hr />
<h1 id="properties"><a class="header" href="#properties"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="lattice"><a class="header" href="#lattice"><strong><code>Lattice</code></strong></a></h1>
<h2 id="array-of-vectors"><a class="header" href="#array-of-vectors"><code>Array of</code> <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vectors</code></a></a></h2>
<p>Offsets from interpolation lattice corners. Do not modify length.</p>
<p>First four values represent the bottom four corners, second four the
top four corners.</p>
<p>Because this is a list of offsets, if all vectors are zero the trilinear interpolation
will not modify the mesh, it will just return the original vertex positions.</p>
</li>
</ul>
<hr />
<h1 id="functions-1"><a class="header" href="#functions-1"><strong>Functions</strong></a></h1>
<ul>
<li>
<h1 id="centroid"><a class="header" href="#centroid"><strong><code>Centroid</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - Centroid Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_centroid_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#centroid"><code>UTrilerpMeshComponent::Centroid</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Computes the centroid of four points.</p>
<p>All four points are assumed to be in the same coordinate frame.</p>
  </summary>
<hr />
<h1 id="inputs"><a class="header" href="#inputs"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="a"><a class="header" href="#a"><strong><code>A</code></strong></a></h2>
<h3 id="vector"><a class="header" href="#vector"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vector</code></a></a></h3>
</li>
<li>
<h2 id="b"><a class="header" href="#b"><strong><code>B</code></strong></a></h2>
<h3 id="vector-1"><a class="header" href="#vector-1"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vector</code></a></a></h3>
</li>
<li>
<h2 id="c"><a class="header" href="#c"><strong><code>C</code></strong></a></h2>
<h3 id="vector-2"><a class="header" href="#vector-2"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vector</code></a></a></h3>
</li>
<li>
<h2 id="d"><a class="header" href="#d"><strong><code>D</code></strong></a></h2>
<h3 id="vector-3"><a class="header" href="#vector-3"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vector</code></a></a></h3>
</li>
</ul>
<h1 id="outputs"><a class="header" href="#outputs"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h2 id="return-value"><a class="header" href="#return-value"><strong><code>Return Value</code></strong></a></h2>
<h3 id="vector-4"><a class="header" href="#vector-4"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vector</code></a></a></h3>
<p>The centroid of A-B-C-D</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="debugdrawlattice"><a class="header" href="#debugdrawlattice"><strong><code>DebugDrawLattice</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - DebugDrawLattice Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_debugdrawlattice_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#debugdrawlattice"><code>UTrilerpMeshComponent::DebugDrawLattice</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Visualizes the current lattice configuration.</p>
  </summary>
<hr />
<h1 id="inputs-1"><a class="header" href="#inputs-1"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="lifetime"><a class="header" href="#lifetime"><strong><code>Lifetime</code></strong></a></h2>
<h3 id="float"><a class="header" href="#float"><code>Float</code></a></h3>
<p>The duration, in seconds, to display the debug markers for.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="getcentroid"><a class="header" href="#getcentroid"><strong><code>GetCentroid</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - GetCentroid Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_getcentroid_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#getcentroid"><code>UTrilerpMeshComponent::GetCentroid</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Computes the centroid (in world-space) of the specified lattice face.</p>
  </summary>
<hr />
<h1 id="inputs-2"><a class="header" href="#inputs-2"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="face"><a class="header" href="#face"><strong><code>Face</code></strong></a></h2>
<h3 id="elatticeface"><a class="header" href="#elatticeface"><a href="blueprint-api/classes/../enums/ELatticeFace.html"><code>ELatticeFace</code></a></a></h3>
<p>The duration, in seconds, to display the debug markers for.</p>
</li>
</ul>
<h1 id="outputs-1"><a class="header" href="#outputs-1"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h2 id="return-value-1"><a class="header" href="#return-value-1"><strong><code>Return Value</code></strong></a></h2>
<h3 id="vector-5"><a class="header" href="#vector-5"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vector</code></a></a></h3>
<p>The centroid of the target Face.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="getcornersws"><a class="header" href="#getcornersws"><strong><code>GetCornersWS</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - GetCornersWS Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_getcornersws_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#getcornersws"><code>UTrilerpMeshComponent::GetCornersWS</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Gets the world-space positions of the Lattice corners (including offsets).</p>
  </summary>
<hr />
<h1 id="outputs-2"><a class="header" href="#outputs-2"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h2 id="return-value-2"><a class="header" href="#return-value-2"><strong><code>Return Value</code></strong></a></h2>
<h3 id="array-of-vectors-1"><a class="header" href="#array-of-vectors-1"><code>Array of</code> <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vectors</code></a></a></h3>
<p>The world-space positions of the current lattice points.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="getsourcecornersws"><a class="header" href="#getsourcecornersws"><strong><code>GetSourceCornersWS</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - GetSourceCornersWS Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_getsourcecornersws_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#getsourcecornersws"><code>UTrilerpMeshComponent::GetSourceCornersWS</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Gets the world-space positions of the untransformed Lattice corners. i.e. the original/base position based on the input mesh bounds.</p>
  </summary>
<hr />
<h1 id="outputs-3"><a class="header" href="#outputs-3"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h2 id="return-value-3"><a class="header" href="#return-value-3"><strong><code>Return Value</code></strong></a></h2>
<h3 id="array-of-vectors-2"><a class="header" href="#array-of-vectors-2"><code>Array of</code> <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vectors</code></a></a></h3>
<p>The world-space positions of the untransformed lattice points.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="initfromdynamicmesh"><a class="header" href="#initfromdynamicmesh"><strong><code>InitFromDynamicMesh</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - InitFromDynamicMesh Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_initfromdynamicmesh_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#initfromdynamicmesh"><code>UTrilerpMeshComponent::InitFromDynamicMesh</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Initializes the dynamic mesh from another given dynamic mesh.</p>
  </summary>
<hr />
<h1 id="inputs-3"><a class="header" href="#inputs-3"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="mesh"><a class="header" href="#mesh"><strong><code>Mesh</code></strong></a></h2>
<h3 id="dynamic-mesh"><a class="header" href="#dynamic-mesh"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/DynamicMesh"><code>Dynamic Mesh</code></a></a></h3>
<p>Mesh to copy from.</p>
</li>
</ul>
<h1 id="outputs-4"><a class="header" href="#outputs-4"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h2 id="return-value-4"><a class="header" href="#return-value-4"><strong><code>Return Value</code></strong></a></h2>
<h3 id="bool"><a class="header" href="#bool"><code>bool</code></a></h3>
<p><code>True</code> if copying the mesh data was successful, otherwise <code>False</code>.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="initfromskeletalmesh"><a class="header" href="#initfromskeletalmesh"><strong><code>InitFromSkeletalMesh</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - InitFromSkeletalMesh Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_initfromskeletalmesh_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#initfromskeletalmesh"><code>UTrilerpMeshComponent::InitFromSkeletalMesh</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Initializes the dynamic mesh from a given skeletal mesh.</p>
  </summary>
<hr />
<h1 id="inputs-4"><a class="header" href="#inputs-4"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="mesh-1"><a class="header" href="#mesh-1"><strong><code>Mesh</code></strong></a></h2>
<h3 id="skeletal-mesh"><a class="header" href="#skeletal-mesh"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Components/SkeletalMesh"><code>Skeletal Mesh</code></a></a></h3>
<p>Mesh to copy from.</p>
</li>
</ul>
<h1 id="outputs-5"><a class="header" href="#outputs-5"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h2 id="return-value-5"><a class="header" href="#return-value-5"><strong><code>Return Value</code></strong></a></h2>
<h3 id="bool-1"><a class="header" href="#bool-1"><code>bool</code></a></h3>
<p><code>True</code> if copying the mesh data was successful, otherwise <code>False</code>.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="initfromstaticmesh"><a class="header" href="#initfromstaticmesh"><strong><code>InitFromStaticMesh</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - InitFromStaticMesh Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_initfromstaticmesh_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#initfromstaticmesh"><code>UTrilerpMeshComponent::InitFromStaticMesh</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Initializes the dynamic mesh from a given static mesh.</p>
  </summary>
<hr />
<h1 id="inputs-5"><a class="header" href="#inputs-5"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="mesh-2"><a class="header" href="#mesh-2"><strong><code>Mesh</code></strong></a></h2>
<h3 id="static-mesh"><a class="header" href="#static-mesh"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Components/StaticMesh"><code>Static Mesh</code></a></a></h3>
<p>Mesh to copy from.</p>
</li>
<li>
<h2 id="include-collision"><a class="header" href="#include-collision"><strong><code>Include Collision</code></strong></a></h2>
<h3 id="eincludecollisiontype"><a class="header" href="#eincludecollisiontype"><a href="blueprint-api/classes/../enums/EIncludeCollisionType.html"><code>EIncludeCollisionType</code></a></a></h3>
<p>If not set to <code>None</code>, then will also copy the given static mesh's collision data and update/generate collisions each time
<a href="blueprint-api/classes/TrilerpMeshComponent.html#updatemesh">UpdateMesh</a> is called.</p>
</li>
</ul>
<h1 id="outputs-6"><a class="header" href="#outputs-6"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h2 id="return-value-6"><a class="header" href="#return-value-6"><strong><code>Return Value</code></strong></a></h2>
<h3 id="bool-2"><a class="header" href="#bool-2"><code>bool</code></a></h3>
<p><code>True</code> if copying the mesh data was successful, otherwise <code>False</code>.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="rotateface"><a class="header" href="#rotateface"><strong><code>RotateFace</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - RotateFace Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_rotateface_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#rotateface"><code>UTrilerpMeshComponent::RotateFace</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Applies a rotation to one whole side of the lattice, relative to its current orientation, around the centroid of the face vertices.</p>
<p>Calls <a href="blueprint-api/classes/TrilerpMeshComponent.html#updatemesh">UpdateMesh</a>.</p>
  </summary>
<hr />
<h1 id="inputs-6"><a class="header" href="#inputs-6"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="face-1"><a class="header" href="#face-1"><strong><code>Face</code></strong></a></h2>
<h3 id="elatticeface-1"><a class="header" href="#elatticeface-1"><a href="blueprint-api/classes/../enums/ELatticeFace.html"><code>ELatticeFace</code></a></a></h3>
<p>Face to rotate.</p>
</li>
<li>
<h2 id="rotation"><a class="header" href="#rotation"><strong><code>Rotation</code></strong></a></h2>
<h3 id="rotator"><a class="header" href="#rotator"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Rotator"><code>Rotator</code></a></a></h3>
<p>Rotation to apply.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="scaleface"><a class="header" href="#scaleface"><strong><code>ScaleFace</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - ScaleFace Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_scaleface_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#scaleface"><code>UTrilerpMeshComponent::ScaleFace</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Scales a face by moving its corners relative to their centroid.</p>
<p>Calls <a href="blueprint-api/classes/TrilerpMeshComponent.html#updatemesh">UpdateMesh</a>.</p>
  </summary>
<hr />
<h1 id="inputs-7"><a class="header" href="#inputs-7"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="face-2"><a class="header" href="#face-2"><strong><code>Face</code></strong></a></h2>
<h3 id="elatticeface-2"><a class="header" href="#elatticeface-2"><a href="blueprint-api/classes/../enums/ELatticeFace.html"><code>ELatticeFace</code></a></a></h3>
<p>Face to Scale.</p>
</li>
<li>
<h2 id="scale"><a class="header" href="#scale"><strong><code>Scale</code></strong></a></h2>
<h3 id="vector-6"><a class="header" href="#vector-6"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vector</code></a></a></h3>
<p>Scale factor</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="setfacetranslation"><a class="header" href="#setfacetranslation"><strong><code>SetFaceTranslation</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - SetFaceTranslation Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_setfacetranslation_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#setfacetranslation"><code>UTrilerpMeshComponent::SetFaceTranslation</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Sets the translation (absolute movement) of one whole side of the lattice, relative to the <strong>base</strong> position of the vertices on that face.</p>
<p>Given translation is expected to be in world space.</p>
<p>Calls <a href="blueprint-api/classes/TrilerpMeshComponent.html#updatemesh">UpdateMesh</a>.</p>
  </summary>
<hr />
<h1 id="inputs-8"><a class="header" href="#inputs-8"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="face-3"><a class="header" href="#face-3"><strong><code>Face</code></strong></a></h2>
<h3 id="elatticeface-3"><a class="header" href="#elatticeface-3"><a href="blueprint-api/classes/../enums/ELatticeFace.html"><code>ELatticeFace</code></a></a></h3>
<p>Face to translate.</p>
</li>
<li>
<h2 id="translation"><a class="header" href="#translation"><strong><code>Translation</code></strong></a></h2>
<h3 id="vector-7"><a class="header" href="#vector-7"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vector</code></a></a></h3>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="setlatticews"><a class="header" href="#setlatticews"><strong><code>SetLatticeWS</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - SetLatticeWS Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_setlatticews_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#setlatticews"><code>UTrilerpMeshComponent::SetLatticeWS</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Sets the lattice corners to the given world-space coordinates.</p>
  </summary>
<hr />
<h1 id="inputs-9"><a class="header" href="#inputs-9"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="wslattice"><a class="header" href="#wslattice"><strong><code>WSLattice</code></strong></a></h2>
<h3 id="array-of-vectors-3"><a class="header" href="#array-of-vectors-3"><code>Array of</code> <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vectors</code></a></a></h3>
<p>New lattice points, in world-space. Should have length <code>8</code>.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="translateface"><a class="header" href="#translateface"><strong><code>TranslateFace</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - Translate Face Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_translateface_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#translateface"><code>UTrilerpMeshComponent::TranslateFace</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Applies a translation (relative movement) to one whole side of the lattice.</p>
<p>Given translation is expected to be in world space.</p>
<p>Calls <a href="blueprint-api/classes/TrilerpMeshComponent.html#updatemesh">UpdateMesh</a>.</p>
  </summary>
<hr />
<h1 id="inputs-10"><a class="header" href="#inputs-10"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h2 id="face-4"><a class="header" href="#face-4"><strong><code>Face</code></strong></a></h2>
<h3 id="elatticeface-4"><a class="header" href="#elatticeface-4"><a href="blueprint-api/classes/../enums/ELatticeFace.html"><code>ELatticeFace</code></a></a></h3>
<p>Face to translate.</p>
</li>
<li>
<h2 id="delta-translation"><a class="header" href="#delta-translation"><strong><code>Delta Translation</code></strong></a></h2>
<h3 id="vector-8"><a class="header" href="#vector-8"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/Math/Vector"><code>Vector</code></a></a></h3>
<p>Relative translation amount.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="updatemesh"><a class="header" href="#updatemesh"><strong><code>UpdateMesh</code></strong></a></h1>
  <p align="center">
  <img alt="TrilerpMeshComponent - UpdateMesh Node" src="blueprint-api/classes/../../assets/bpapi_trilerpmeshcomponent_updatemesh_node.png" />
  </p>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/classes/../../reference/classes/UTrilerpMeshComponent.html#updatemesh"><code>UTrilerpMeshComponent::UpdateMesh</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
  <details>
  <summary>
<p>Updates the underlying mesh data to match the current Lattice configuration.</p>
<p>Should be called whenever Lattice has been modified to keep the mesh up-to-date.</p>
  </summary>
<hr />
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blueprint-functions"><a class="header" href="#blueprint-functions">Blueprint Functions</a></h1>
<h1 id="pages-3"><a class="header" href="#pages-3">Pages</a></h1>
<ul>
<li><a href="blueprint-api/functions//trilinear-interpolation-docs/blueprint-api/functions/TrilinearInterpolationMesh.html">Trilinear Interpolation (Mesh)</a></li>
<li><a href="blueprint-api/functions//trilinear-interpolation-docs/blueprint-api/functions/TrilinearInterpolationPoint.html">Trilinear Interpolation (Point)</a></li>
<li><a href="blueprint-api/functions//trilinear-interpolation-docs/blueprint-api/functions/TrilinearInterpolationVertices.html">Trilinear Interpolation (Vertices)</a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bp-function-trilinear-interpolation-mesh"><a class="header" href="#bp-function-trilinear-interpolation-mesh"><strong>BP Function: <code>Trilinear Interpolation (Mesh)</code></strong></a></h1>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/functions/../../reference/classes/UNBTrilinearInterpolationBPLibrary.html#trilinearinterpolation2"><code>UNBTrilinearInterpolationBPLibrary</code></a></th></tr></thead><tbody>
</tbody></table>
</div><p align="center">
<img alt="Trilinear Interpolation (Mesh) Node" src="blueprint-api/functions/../../assets/bpapi_trilinear_interpolation_mesh_node.png" />
</p>
<hr />
<p>Performs trilinear interpolation on a given <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/DynamicMesh">Dynamic Mesh</a>.</p>
<p>The mesh will be directly modified.</p>
<p>If the required inputs are invalid, the original mesh will be returned.</p>
<hr />
<h1 id="inputs-11"><a class="header" href="#inputs-11"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h1 id="targetmesh"><a class="header" href="#targetmesh"><strong><code>TargetMesh</code></strong></a></h1>
<h2 id="dynamic-mesh-1"><a class="header" href="#dynamic-mesh-1"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/DynamicMesh"><code>Dynamic Mesh</code></a></a></h2>
<p>The mesh to transform.</p>
</li>
<li>
<h1 id="lattice-1"><a class="header" href="#lattice-1"><strong><code>Lattice</code></strong></a></h1>
<h2 id="array-of-vector"><a class="header" href="#array-of-vector">Array of <code>Vector</code></a></h2>
<p>List of offsets for the corners of the lattics cube. A value of <code>0</code> will result in no change. MUST contain 8 entries!</p>
</li>
<li>
<h1 id="minbound"><a class="header" href="#minbound"><strong><code>MinBound</code></strong></a></h1>
<h2 id="vector-9"><a class="header" href="#vector-9"><code>Vector</code></a></h2>
<p>The minimum corner of the bounding box for the (original, untransformed) mesh.</p>
</li>
<li>
<h1 id="maxbound"><a class="header" href="#maxbound"><strong><code>MaxBound</code></strong></a></h1>
<h2 id="vector-10"><a class="header" href="#vector-10"><code>Vector</code></a></h2>
<p>The maximum corner of the bounding box for the (original, untransformed) mesh.</p>
</li>
<li>
<h1 id="origin"><a class="header" href="#origin"><strong><code>Origin</code></strong></a></h1>
<h2 id="vector-11"><a class="header" href="#vector-11"><code>Vector</code></a></h2>
<p>Location that the bounds and mesh vertices are relative to.</p>
</li>
</ul>
<h1 id="outputs-7"><a class="header" href="#outputs-7"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h1 id="target-mesh"><a class="header" href="#target-mesh"><strong><code>Target Mesh</code></strong></a></h1>
<h2 id="dynamic-mesh-2"><a class="header" href="#dynamic-mesh-2"><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/DynamicMesh"><code>Dynamic Mesh</code></a></a></h2>
<p>The transformed mesh.</p>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bp-function-trilinear-interpolation-point"><a class="header" href="#bp-function-trilinear-interpolation-point"><strong>BP Function: <code>Trilinear Interpolation (Point)</code></strong></a></h1>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/functions/../../reference/classes/UNBTrilinearInterpolationBPLibrary.html#tinterp"><code>UNBTrilinearInterpolationBPLibrary</code></a></th></tr></thead><tbody>
</tbody></table>
</div><p align="center">
<img alt="Trilinear Interpolation (Point) Node" src="blueprint-api/functions/../../assets/bpapi_trilinear_interpolation_point_node.png" />
</p>
<hr />
<p>Performs trilinear interpolation on an individual point/vertex location.</p>
<p>This is mostly only useful if you are extending the plugin's capabilities or using the interpolation for something very specific to your project.</p>
<p>If the required inputs are invalid, the original mesh will be returned.</p>
<hr />
<h1 id="inputs-12"><a class="header" href="#inputs-12"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h1 id="point"><a class="header" href="#point"><strong><code>Point</code></strong></a></h1>
<h2 id="vector-12"><a class="header" href="#vector-12"><code>Vector</code></a></h2>
<p>The point to transform.</p>
</li>
<li>
<h1 id="lattice-2"><a class="header" href="#lattice-2"><strong><code>Lattice</code></strong></a></h1>
<h2 id="array-of-vector-1"><a class="header" href="#array-of-vector-1">Array of <code>Vector</code></a></h2>
<p>List of offsets for the corners of the lattics cube. A value of <code>0</code> will result in no change. MUST contain 8 entries!</p>
</li>
<li>
<h1 id="minbound-1"><a class="header" href="#minbound-1"><strong><code>MinBound</code></strong></a></h1>
<h2 id="vector-13"><a class="header" href="#vector-13"><code>Vector</code></a></h2>
<p>The minimum corner of the bounding box for whatever the point came from.</p>
</li>
<li>
<h1 id="maxbound-1"><a class="header" href="#maxbound-1"><strong><code>MaxBound</code></strong></a></h1>
<h2 id="vector-14"><a class="header" href="#vector-14"><code>Vector</code></a></h2>
<p>The maximum corner of the bounding box for whatever the point came from.</p>
</li>
</ul>
<h1 id="outputs-8"><a class="header" href="#outputs-8"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h1 id="return-value-7"><a class="header" href="#return-value-7"><strong><code>Return Value</code></strong></a></h1>
<h2 id="vector-15"><a class="header" href="#vector-15"><code>Vector</code></a></h2>
<p>The transformed point.</p>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bp-function-trilinear-interpolation-vertices"><a class="header" href="#bp-function-trilinear-interpolation-vertices"><strong>BP Function: <code>Trilinear Interpolation (Vertices)</code></strong></a></h1>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/functions/../../reference/classes/UNBTrilinearInterpolationBPLibrary.html#trilinearinterpolation"><code>UNBTrilinearInterpolationBPLibrary</code></a></th></tr></thead><tbody>
</tbody></table>
</div><p align="center">
<img alt="Trilinear Interpolation (Vertices) Node" src="blueprint-api/functions/../../assets/bpapi_trilinear_interpolation_vertices_node.png" />
</p>
<hr />
<p>Performs trilinear interpolation on a given <code>GeometryScriptVectorList</code>.</p>
<p>The list will be directly modified, you may wish to <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/GeometryScript/ListUtils/DuplicateVectorList">create a copy</a> beforehand.</p>
<p>If the required inputs are invalid, the original list will be returned unchanged.</p>
<hr />
<h1 id="inputs-13"><a class="header" href="#inputs-13"><strong>Inputs</strong></a></h1>
<ul>
<li>
<h1 id="vertices"><a class="header" href="#vertices"><strong><code>Vertices</code></strong></a></h1>
<h2 id="geometryscriptvectorlist"><a class="header" href="#geometryscriptvectorlist"><code>GeometryScriptVectorList</code></a></h2>
<p>The vertices to transform.</p>
</li>
<li>
<h1 id="lattice-3"><a class="header" href="#lattice-3"><strong><code>Lattice</code></strong></a></h1>
<h2 id="array-of-vector-2"><a class="header" href="#array-of-vector-2">Array of <code>Vector</code></a></h2>
<p>List of offsets for the corners of the lattics cube. A value of <code>0</code> will result in no change. MUST contain 8 entries!</p>
</li>
<li>
<h1 id="minbound-2"><a class="header" href="#minbound-2"><strong><code>MinBound</code></strong></a></h1>
<h2 id="vector-16"><a class="header" href="#vector-16"><code>Vector</code></a></h2>
<p>The minimum corner of the bounding box for the (original, untransformed) vertices.</p>
</li>
<li>
<h1 id="maxbound-2"><a class="header" href="#maxbound-2"><strong><code>MaxBound</code></strong></a></h1>
<h2 id="vector-17"><a class="header" href="#vector-17"><code>Vector</code></a></h2>
<p>The maximum corner of the bounding box for the (original, untransformed) vertices.</p>
</li>
<li>
<h1 id="origin-1"><a class="header" href="#origin-1"><strong><code>Origin</code></strong></a></h1>
<h2 id="vector-18"><a class="header" href="#vector-18"><code>Vector</code></a></h2>
<p>Location that the bounds and vertices are relative to.</p>
</li>
</ul>
<h1 id="outputs-9"><a class="header" href="#outputs-9"><strong>Outputs</strong></a></h1>
<ul>
<li>
<h1 id="vertices-1"><a class="header" href="#vertices-1"><strong><code>Vertices</code></strong></a></h1>
<h2 id="geometryscriptvectorlist-1"><a class="header" href="#geometryscriptvectorlist-1"><code>GeometryScriptVectorList</code></a></h2>
<p>The transformed vertices.</p>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pages-4"><a class="header" href="#pages-4">Pages</a></h1>
<ul>
<li><a href="blueprint-api/enums//trilinear-interpolation-docs/blueprint-api/enums/EIncludeCollisionType.html">EIncludeCollisionType</a></li>
<li><a href="blueprint-api/enums//trilinear-interpolation-docs/blueprint-api/enums/ELatticeFace.html">ELatticeFace</a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bp-enum-eincludecollisiontype"><a class="header" href="#bp-enum-eincludecollisiontype"><strong>BP Enum: <code>EIncludeCollisionType</code></strong></a></h1>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/enums/../../reference/enums/EIncludeCollisionType.html"><code>EIncludeCollisionType</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
<p>Which type of collision mesh to use/generate when updating a deformed mesh.</p>
<hr />
<h1 id="values"><a class="header" href="#values"><strong>Values</strong></a></h1>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>None</td><td></td></tr>
<tr><td>Simple</td><td></td></tr>
<tr><td>Complex</td><td></td></tr>
</tbody></table>
</div>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bp-enum-elatticeface"><a class="header" href="#bp-enum-elatticeface"><strong>BP Enum: <code>ELatticeFace</code></strong></a></h1>
<div class="table-wrapper"><table><thead><tr><th>C++ Impl</th><th><a href="blueprint-api/enums/../../reference/enums/ELatticeFace.html"><code>ELatticeFace</code></a></th></tr></thead><tbody>
</tbody></table>
</div>
<hr />
<p>Represents the faces of a deformation lattice.</p>
<hr />
<h1 id="values-1"><a class="header" href="#values-1"><strong>Values</strong></a></h1>
<div class="table-wrapper"><table><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody>
<tr><td>Bottom</td><td>-Z</td></tr>
<tr><td>Top</td><td>+Z</td></tr>
<tr><td>South</td><td>-Y</td></tr>
<tr><td>North</td><td>+Y</td></tr>
<tr><td>West</td><td>+X</td></tr>
<tr><td>East</td><td>-X</td></tr>
</tbody></table>
</div>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-api-reference"><a class="header" href="#c-api-reference">C++ API Reference</a></h1>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<ul>
<li><a href="/trilinear-interpolation-docs/reference/enums/EIncludeCollisionType.html"><code>EIncludeCollisionType</code></a></li>
<li><a href="/trilinear-interpolation-docs/reference/enums/ELatticeFace.html"><code>ELatticeFace</code></a></li>
</ul>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<ul>
<li><a href="/trilinear-interpolation-docs/reference/structs/HNBLatticeCornerProxy.html"><code>HNBLatticeCornerProxy</code></a></li>
<li><a href="/trilinear-interpolation-docs/reference/structs/HNBLatticeFaceProxy.html"><code>HNBLatticeFaceProxy</code></a></li>
</ul>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<ul>
<li><a href="/trilinear-interpolation-docs/reference/classes/FNBTrilerpEditorModule.html"><code>FNBTrilerpEditorModule</code></a></li>
<li><a href="/trilinear-interpolation-docs/reference/classes/FNBTrilinearInterpolationModule.html"><code>FNBTrilinearInterpolationModule</code></a></li>
<li><a href="/trilinear-interpolation-docs/reference/classes/NBTrilinearVisualizer.html"><code>NBTrilinearVisualizer</code></a></li>
<li><a href="/trilinear-interpolation-docs/reference/classes/UNBTrilinearInterpolation.html"><code>UNBTrilinearInterpolation</code></a></li>
<li><a href="/trilinear-interpolation-docs/reference/classes/UNBTrilinearInterpolationBPLibrary.html"><code>UNBTrilinearInterpolationBPLibrary</code></a></li>
<li><a href="/trilinear-interpolation-docs/reference/classes/UTrilerpMeshComponent.html"><code>UTrilerpMeshComponent</code></a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-1"><a class="header" href="#enums-1">Enums</a></h1>
<ul>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/enums/EIncludeCollisionType.html"><code>EIncludeCollisionType</code></a></li>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/enums/ELatticeFace.html"><code>ELatticeFace</code></a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-eincludecollisiontype"><a class="header" href="#enum-eincludecollisiontype"><strong>Enum: <code>EIncludeCollisionType</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 29

enum class EIncludeCollisionType : uint8 {
    NONE    = 0 UMETA(DisplayName = "None"),
    SIMPLE  = 1 UMETA(DisplayName = "Simple"),
    COMPLEX = 2 UMETA(DisplayName = "Complex")
};
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers"><a class="header" href="#specifiers">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Which type of collision mesh to use/generate when
updating a deformed mesh.</p>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-elatticeface"><a class="header" href="#enum-elatticeface"><strong>Enum: <code>ELatticeFace</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 15

enum class ELatticeFace : uint8 {
    BOTTOM = 0 UMETA(DisplayName = "Bottom"),
    TOP    = 1 UMETA(DisplayName = "Top"),
    SOUTH  = 2 UMETA(DisplayName = "South"),
    NORTH  = 3 UMETA(DisplayName = "North"),
    WEST   = 4 UMETA(DisplayName = "West"),
    EAST   = 5 UMETA(DisplayName = "East"),
    NONE   = 6
};
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-1"><a class="header" href="#specifiers-1">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Represents the faces of a deformation lattice.</p>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-1"><a class="header" href="#structs-1">Structs</a></h1>
<ul>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/structs/HNBLatticeCornerProxy.html"><code>HNBLatticeCornerProxy</code></a></li>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/structs/HNBLatticeFaceProxy.html"><code>HNBLatticeFaceProxy</code></a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-hnblatticecornerproxy"><a class="header" href="#struct-hnblatticecornerproxy"><strong>Struct: <code>HNBLatticeCornerProxy</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 30

struct HNBLatticeCornerProxy
    : public HComponentVisProxy;
</code></pre>
<hr />
<p>Hit proxy for handling input on lattice corners</p>
<hr />
<h1 id="properties-1"><a class="header" href="#properties-1"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="latticeid"><a class="header" href="#latticeid"><strong><code>LatticeID</code></strong></a></h1>
<pre><code class="language-cpp">public:
int32 LatticeID;
</code></pre>
<hr />
</li>
</ul>
<hr />
<h1 id="constructors"><a class="header" href="#constructors"><strong>Constructors</strong></a></h1>
<ul>
<li>
<h1 id="hnblatticecornerproxy"><a class="header" href="#hnblatticecornerproxy"><strong><code>HNBLatticeCornerProxy</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 35

public:
HNBLatticeCornerProxy(
    const UActorComponent* InComponent,
    int32 LatticeID
);
</code></pre>
  <details>
<hr />
<h1 id="arguments"><a class="header" href="#arguments"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="incomponent"><a class="header" href="#incomponent"><strong><code>InComponent</code></strong></a></h2>
<pre><code class="language-cpp">const UActorComponent* InComponent
</code></pre>
</li>
<li>
<h2 id="latticeid-1"><a class="header" href="#latticeid-1"><strong><code>LatticeID</code></strong></a></h2>
<pre><code class="language-cpp">int32 LatticeID
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-hnblatticefaceproxy"><a class="header" href="#struct-hnblatticefaceproxy"><strong>Struct: <code>HNBLatticeFaceProxy</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 17

struct HNBLatticeFaceProxy
    : public HComponentVisProxy;
</code></pre>
<hr />
<p>Hit proxy for handling input on lattice faces</p>
<hr />
<h1 id="properties-2"><a class="header" href="#properties-2"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="faceid"><a class="header" href="#faceid"><strong><code>FaceID</code></strong></a></h1>
<pre><code class="language-cpp">public:
ELatticeFace FaceID;
</code></pre>
<hr />
</li>
</ul>
<hr />
<h1 id="constructors-1"><a class="header" href="#constructors-1"><strong>Constructors</strong></a></h1>
<ul>
<li>
<h1 id="hnblatticefaceproxy"><a class="header" href="#hnblatticefaceproxy"><strong><code>HNBLatticeFaceProxy</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 22

public:
HNBLatticeFaceProxy(
    const UActorComponent* InComponent,
    ELatticeFace FaceID
);
</code></pre>
  <details>
<hr />
<h1 id="arguments-1"><a class="header" href="#arguments-1"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="incomponent-1"><a class="header" href="#incomponent-1"><strong><code>InComponent</code></strong></a></h2>
<pre><code class="language-cpp">const UActorComponent* InComponent
</code></pre>
</li>
<li>
<h2 id="faceid-1"><a class="header" href="#faceid-1"><strong><code>FaceID</code></strong></a></h2>
<pre><code class="language-cpp">ELatticeFace FaceID
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-1"><a class="header" href="#classes-1">Classes</a></h1>
<ul>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/classes/FNBTrilerpEditorModule.html"><code>FNBTrilerpEditorModule</code></a></li>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/classes/FNBTrilinearInterpolationModule.html"><code>FNBTrilinearInterpolationModule</code></a></li>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/classes/NBTrilinearVisualizer.html"><code>NBTrilinearVisualizer</code></a></li>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/classes/UNBTrilinearInterpolation.html"><code>UNBTrilinearInterpolation</code></a></li>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/classes/UNBTrilinearInterpolationBPLibrary.html"><code>UNBTrilinearInterpolationBPLibrary</code></a></li>
<li><a href="reference//trilinear-interpolation-docs/reference/reference/classes/UTrilerpMeshComponent.html"><code>UTrilerpMeshComponent</code></a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-fnbtrilerpeditormodule"><a class="header" href="#class-fnbtrilerpeditormodule"><strong>Class: <code>FNBTrilerpEditorModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilerpEditorModule.h : 14

class FNBTrilerpEditorModule
    : public IModuleInterface;
</code></pre>
<hr />
<p>Editor module for supporting improved visualization and editor tools
related to Trilinear Mesh Interpoloation</p>
<hr />
<h1 id="methods"><a class="header" href="#methods"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="shutdownmodule"><a class="header" href="#shutdownmodule"><strong><code>ShutdownModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilerpEditorModule.h : 18

public:
virtual void ShutdownModule() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="startupmodule"><a class="header" href="#startupmodule"><strong><code>StartupModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilerpEditorModule.h : 17

public:
virtual void StartupModule() override;
</code></pre>
  <details>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-fnbtrilinearinterpolationmodule"><a class="header" href="#class-fnbtrilinearinterpolationmodule"><strong>Class: <code>FNBTrilinearInterpolationModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationModule.h : 10

class FNBTrilinearInterpolationModule
    : public IModuleInterface;
</code></pre>
<hr />
<p>Runtime module for Trilinear Interpolation support</p>
<hr />
<h1 id="methods-1"><a class="header" href="#methods-1"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="shutdownmodule-1"><a class="header" href="#shutdownmodule-1"><strong><code>ShutdownModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationModule.h : 15

public:
virtual void ShutdownModule() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="startupmodule-1"><a class="header" href="#startupmodule-1"><strong><code>StartupModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationModule.h : 14

public:
virtual void StartupModule() override;
</code></pre>
  <details>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-nbtrilinearvisualizer"><a class="header" href="#class-nbtrilinearvisualizer"><strong>Class: <code>NBTrilinearVisualizer</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 47

class NBTrilinearVisualizer
    : public FComponentVisualizer;
</code></pre>
<hr />
<p>Responsible for showing the lattice configuration and editing widgets on a <strong><code>UTrilinearInterpolatedMeshComponent</code></strong>
when it's selected in-editor.</p>
<p>Allows the user to freely edit the lattice through regular translation/rotation/scale controls rather than needing to
enter corner offsets manually.</p>
<hr />
<h1 id="methods-2"><a class="header" href="#methods-2"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="drawvisualization"><a class="header" href="#drawvisualization"><strong><code>DrawVisualization</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 51

public:
virtual void DrawVisualization(
    const UActorComponent* Component,
    const FSceneView* View,
    FPrimitiveDrawInterface* PDI
) override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-2"><a class="header" href="#arguments-2"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="component"><a class="header" href="#component"><strong><code>Component</code></strong></a></h2>
<pre><code class="language-cpp">const UActorComponent* Component
</code></pre>
</li>
<li>
<h2 id="view"><a class="header" href="#view"><strong><code>View</code></strong></a></h2>
<pre><code class="language-cpp">const FSceneView* View
</code></pre>
</li>
<li>
<h2 id="pdi"><a class="header" href="#pdi"><strong><code>PDI</code></strong></a></h2>
<pre><code class="language-cpp">FPrimitiveDrawInterface* PDI
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="endediting"><a class="header" href="#endediting"><strong><code>EndEditing</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 55

public:
virtual void EndEditing() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="getwidgetlocation"><a class="header" href="#getwidgetlocation"><strong><code>GetWidgetLocation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 53

public:
virtual bool GetWidgetLocation(
    const FEditorViewportClient* ViewportClient,
    FVector&amp; OutLocation
) const override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-3"><a class="header" href="#arguments-3"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="viewportclient"><a class="header" href="#viewportclient"><strong><code>ViewportClient</code></strong></a></h2>
<pre><code class="language-cpp">const FEditorViewportClient* ViewportClient
</code></pre>
</li>
<li>
<h2 id="outlocation"><a class="header" href="#outlocation"><strong><code>OutLocation</code></strong></a></h2>
<pre><code class="language-cpp">FVector&amp; OutLocation
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns"><a class="header" href="#returns"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="handleinputdelta"><a class="header" href="#handleinputdelta"><strong><code>HandleInputDelta</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 54

public:
virtual bool HandleInputDelta(
    FEditorViewportClient* ViewportClient,
    FViewport* Viewport,
    FVector&amp; DeltaTranslate,
    FRotator&amp; DeltaRotate,
    FVector&amp; DeltaScale
) override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-4"><a class="header" href="#arguments-4"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="viewportclient-1"><a class="header" href="#viewportclient-1"><strong><code>ViewportClient</code></strong></a></h2>
<pre><code class="language-cpp">FEditorViewportClient* ViewportClient
</code></pre>
</li>
<li>
<h2 id="viewport"><a class="header" href="#viewport"><strong><code>Viewport</code></strong></a></h2>
<pre><code class="language-cpp">FViewport* Viewport
</code></pre>
</li>
<li>
<h2 id="deltatranslate"><a class="header" href="#deltatranslate"><strong><code>DeltaTranslate</code></strong></a></h2>
<pre><code class="language-cpp">FVector&amp; DeltaTranslate
</code></pre>
</li>
<li>
<h2 id="deltarotate"><a class="header" href="#deltarotate"><strong><code>DeltaRotate</code></strong></a></h2>
<pre><code class="language-cpp">FRotator&amp; DeltaRotate
</code></pre>
</li>
<li>
<h2 id="deltascale"><a class="header" href="#deltascale"><strong><code>DeltaScale</code></strong></a></h2>
<pre><code class="language-cpp">FVector&amp; DeltaScale
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-1"><a class="header" href="#returns-1"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="visproxyhandleclick"><a class="header" href="#visproxyhandleclick"><strong><code>VisProxyHandleClick</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearVisualizer.h : 52

public:
virtual bool VisProxyHandleClick(
    FEditorViewportClient* InViewportClient,
    HComponentVisProxy* VisProxy,
    const FViewportClick&amp; Click
) override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-5"><a class="header" href="#arguments-5"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="inviewportclient"><a class="header" href="#inviewportclient"><strong><code>InViewportClient</code></strong></a></h2>
<pre><code class="language-cpp">FEditorViewportClient* InViewportClient
</code></pre>
</li>
<li>
<h2 id="visproxy"><a class="header" href="#visproxy"><strong><code>VisProxy</code></strong></a></h2>
<pre><code class="language-cpp">HComponentVisProxy* VisProxy
</code></pre>
</li>
<li>
<h2 id="click"><a class="header" href="#click"><strong><code>Click</code></strong></a></h2>
<pre><code class="language-cpp">const FViewportClick&amp; Click
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-2"><a class="header" href="#returns-2"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-unbtrilinearinterpolation"><a class="header" href="#class-unbtrilinearinterpolation"><strong>Class: <code>UNBTrilinearInterpolation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolation.h : 13

class UNBTrilinearInterpolation;
</code></pre>
<hr />
<p>Contains the main implementation of Trilinear Interpolation.</p>
<hr />
<h1 id="methods-3"><a class="header" href="#methods-3"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="tinterp"><a class="header" href="#tinterp"><strong><code>TInterp</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolation.h : 48

public:
static FVector TInterp(
    FVector Point,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound
);
</code></pre>
  <details>
  <summary>
<p>Performs trilinear interpolation on a single point</p>
  </summary>
<hr />
<h1 id="arguments-6"><a class="header" href="#arguments-6"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="point-1"><a class="header" href="#point-1"><strong><code>Point</code></strong></a></h2>
<pre><code class="language-cpp">FVector Point
</code></pre>
<p>Point to transform</p>
</li>
<li>
<h2 id="lattice-4"><a class="header" href="#lattice-4"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>The corners of the lattice to use for deformation. Should have length 8.</p>
</li>
<li>
<h2 id="minbound-3"><a class="header" href="#minbound-3"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>Minimum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="maxbound-3"><a class="header" href="#maxbound-3"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>Maximum X,Y,Z of the target mesh's bounding box</p>
</li>
</ul>
<hr />
<h1 id="returns-3"><a class="header" href="#returns-3"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FVector
</code></pre>
<p>Transformed point</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="trilinearinterpolation"><a class="header" href="#trilinearinterpolation"><strong><code>TrilinearInterpolation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolation.h : 26

public:
static UDynamicMesh* TrilinearInterpolation(
    UDynamicMesh* TargetMesh,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound,
    FVector origin
);
</code></pre>
  <details>
  <summary>
<p>Performs trilinear interpolation on the given DynamicMesh.
The mesh should be in its original, undeformed state.</p>
  </summary>
<hr />
<h1 id="arguments-7"><a class="header" href="#arguments-7"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="targetmesh-1"><a class="header" href="#targetmesh-1"><strong><code>TargetMesh</code></strong></a></h2>
<pre><code class="language-cpp">UDynamicMesh* TargetMesh
</code></pre>
<p>Mesh to deform</p>
</li>
<li>
<h2 id="lattice-5"><a class="header" href="#lattice-5"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>The corners of the lattice to use for deformation. Should have length 8.</p>
</li>
<li>
<h2 id="minbound-4"><a class="header" href="#minbound-4"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>Minimum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="maxbound-4"><a class="header" href="#maxbound-4"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>Maximum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="origin-2"><a class="header" href="#origin-2"><strong><code>origin</code></strong></a></h2>
<pre><code class="language-cpp">FVector origin
</code></pre>
<p>Origin the mesh's vertices are relative to</p>
</li>
</ul>
<hr />
<h1 id="returns-4"><a class="header" href="#returns-4"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">UDynamicMesh*
</code></pre>
<p>The transformed mesh</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="trilinearinterpolation-1"><a class="header" href="#trilinearinterpolation-1"><strong><code>TrilinearInterpolation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolation.h : 38

public:
static FGeometryScriptVectorList TrilinearInterpolation(
    FGeometryScriptVectorList Vertices,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound,
    FVector origin
);
</code></pre>
  <details>
  <summary>
<p>Performs trilinear interpolation on a set of vertices.
The vertices should be in their original, undeformed state.</p>
  </summary>
<hr />
<h1 id="arguments-8"><a class="header" href="#arguments-8"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="vertices-2"><a class="header" href="#vertices-2"><strong><code>Vertices</code></strong></a></h2>
<pre><code class="language-cpp">FGeometryScriptVectorList Vertices
</code></pre>
<p>Vertices to transform</p>
</li>
<li>
<h2 id="lattice-6"><a class="header" href="#lattice-6"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>The corners of the lattice to use for deformation. Should have length 8.</p>
</li>
<li>
<h2 id="minbound-5"><a class="header" href="#minbound-5"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>Minimum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="maxbound-5"><a class="header" href="#maxbound-5"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>Maximum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="origin-3"><a class="header" href="#origin-3"><strong><code>origin</code></strong></a></h2>
<pre><code class="language-cpp">FVector origin
</code></pre>
<p>Origin the mesh's vertices are relative to</p>
</li>
</ul>
<hr />
<h1 id="returns-5"><a class="header" href="#returns-5"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FGeometryScriptVectorList
</code></pre>
<p>The transformed vertices</p>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-unbtrilinearinterpolationbplibrary"><a class="header" href="#class-unbtrilinearinterpolationbplibrary"><strong>Class: <code>UNBTrilinearInterpolationBPLibrary</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationBPLibrary.h : 16

class UNBTrilinearInterpolationBPLibrary
    : public UBlueprintFunctionLibrary;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<p>Provides blueprint support for Trilinear Interpolation methods.</p>
<hr />
<h1 id="methods-4"><a class="header" href="#methods-4"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="tinterp-1"><a class="header" href="#tinterp-1"><strong><code>TInterp</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationBPLibrary.h : 61

public:
static FVector TInterp(
    FVector Point,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-2"><a class="header" href="#specifiers-2">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBMeshTools</em></li>
</ul>
<h3 id="meta-specifiers"><a class="header" href="#meta-specifiers">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Trilinear Interpolation (point)</em></li>
<li><strong>Keywords</strong> = <em>Trilinear Interpolation</em></li>
</ul>
  <summary>
<p>Performs trilinear interpolation on a single point.</p>
<p>This may be useful if instead of transforming a mesh you are transforming something like a color.</p>
  </summary>
<hr />
<h1 id="arguments-9"><a class="header" href="#arguments-9"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="point-2"><a class="header" href="#point-2"><strong><code>Point</code></strong></a></h2>
<pre><code class="language-cpp">FVector Point
</code></pre>
</li>
<li>
<h2 id="lattice-7"><a class="header" href="#lattice-7"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>List of offsets for the corners of the lattice cube. A value of 0 will result in no change. MUST contain 8 entries!</p>
</li>
<li>
<h2 id="minbound-6"><a class="header" href="#minbound-6"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>The minimum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="maxbound-6"><a class="header" href="#maxbound-6"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>The maximum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
</ul>
<hr />
<h1 id="returns-6"><a class="header" href="#returns-6"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FVector
</code></pre>
<p>The transformed point</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="trilinearinterpolation-2"><a class="header" href="#trilinearinterpolation-2"><strong><code>TrilinearInterpolation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationBPLibrary.h : 34

public:
static FGeometryScriptVectorList TrilinearInterpolation(
    FGeometryScriptVectorList Vertices,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound,
    FVector Origin
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-3"><a class="header" href="#specifiers-3">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBMeshTools</em></li>
</ul>
<h3 id="meta-specifiers-1"><a class="header" href="#meta-specifiers-1">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Trilinear Interpolation (vertices)</em></li>
<li><strong>Keywords</strong> = <em>Trilinear Interpolation</em></li>
</ul>
  <summary>
<p>Performs trilinear interpolation on the provided list of vertices.</p>
<p>If the required inputs are invalid, the original list of vertices will be returned unmodified.</p>
  </summary>
<hr />
<h1 id="arguments-10"><a class="header" href="#arguments-10"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="vertices-3"><a class="header" href="#vertices-3"><strong><code>Vertices</code></strong></a></h2>
<pre><code class="language-cpp">FGeometryScriptVectorList Vertices
</code></pre>
<p>List of vertices to transform.</p>
</li>
<li>
<h2 id="lattice-8"><a class="header" href="#lattice-8"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>List of offsets for the corners of the lattice cube. A value of 0 will result in no change. MUST contain 8 entries!</p>
</li>
<li>
<h2 id="minbound-7"><a class="header" href="#minbound-7"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>The minimum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="maxbound-7"><a class="header" href="#maxbound-7"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>The maximum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="origin-4"><a class="header" href="#origin-4"><strong><code>Origin</code></strong></a></h2>
<pre><code class="language-cpp">FVector Origin
</code></pre>
<p>The origin of the mesh the vertices are from. Many meshes may have an origin which is not the same as their pivot.</p>
</li>
</ul>
<hr />
<h1 id="returns-7"><a class="header" href="#returns-7"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FGeometryScriptVectorList
</code></pre>
<p>Transformed vertices. If the inputs are invalid (e.g., Latice is empty) then the original given vertices will be returned unmodified.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="trilinearinterpolation2"><a class="header" href="#trilinearinterpolation2"><strong><code>TrilinearInterpolation2</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationBPLibrary.h : 48

public:
static UDynamicMesh* TrilinearInterpolation2(
    UDynamicMesh* TargetMesh,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound,
    FVector origin
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-4"><a class="header" href="#specifiers-4">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBMeshTools</em></li>
</ul>
<h3 id="meta-specifiers-2"><a class="header" href="#meta-specifiers-2">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Trilinear Interpolation (mesh)</em></li>
<li><strong>Keywords</strong> = <em>Trilinear Interpolation</em></li>
</ul>
  <summary>
<p>Performs trilinear interpolation on the provided dynamic mesh.</p>
<p>If the required inputs are invalid, the original mesh will be returned unmodified.</p>
  </summary>
<hr />
<h1 id="arguments-11"><a class="header" href="#arguments-11"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="targetmesh-2"><a class="header" href="#targetmesh-2"><strong><code>TargetMesh</code></strong></a></h2>
<pre><code class="language-cpp">UDynamicMesh* TargetMesh
</code></pre>
<p>Mesh to transform.</p>
</li>
<li>
<h2 id="lattice-9"><a class="header" href="#lattice-9"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>List of offsets for the corners of the lattice cube. A value of 0 will result in no change. MUST contain 8 entries!</p>
</li>
<li>
<h2 id="minbound-8"><a class="header" href="#minbound-8"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>The minimum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="maxbound-8"><a class="header" href="#maxbound-8"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>The maximum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="origin-5"><a class="header" href="#origin-5"><strong><code>origin</code></strong></a></h2>
<pre><code class="language-cpp">FVector origin
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-8"><a class="header" href="#returns-8"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">UDynamicMesh*
</code></pre>
<p>The transformed mesh. If the inputs are invalid (e.g., Lattice is empty) then the original mesh will be returned unmodified.</p>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-utrilerpmeshcomponent"><a class="header" href="#class-utrilerpmeshcomponent"><strong>Class: <code>UTrilerpMeshComponent</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 41

class NBTRILINEARINTERPOLATION_API UTrilerpMeshComponent
    : public UDynamicMeshComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-5"><a class="header" href="#specifiers-5">Specifiers:</a></h3>
<ul>
<li><strong>ClassGroup</strong> = <em>Rendering</em></li>
</ul>
<h3 id="meta-specifiers-3"><a class="header" href="#meta-specifiers-3">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
</ul>
<hr />
<p>A DynamicMeshComponent which supports trilinear interpolation of the
underlying mesh.</p>
<hr />
<h1 id="properties-3"><a class="header" href="#properties-3"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="lattice-10"><a class="header" href="#lattice-10"><strong><code>Lattice</code></strong></a></h1>
<pre><code class="language-cpp">public:
TArray&lt;FVector&gt; Lattice;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-6"><a class="header" href="#specifiers-6">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadWrite</strong></li>
<li><strong>EditAnywhere</strong></li>
<li><strong>EditFixedSize</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
<hr />
  <summary>
  Offsets from interpolation lattice corners. Do not modify length.
<p>First four values represent the bottom four corners, second four the
top four corners.</p>
<p>Because this is a list of offsets, if all vectors are zero the trilinear interpolation
will not modify the mesh, it will just return the original vertex positions.</p>
  </summary>
</li>
<li>
<h1 id="sourcebounds"><a class="header" href="#sourcebounds"><strong><code>SourceBounds</code></strong></a></h1>
<pre><code class="language-cpp">public:
FBoxSphereBounds SourceBounds;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-7"><a class="header" href="#specifiers-7">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadOnly</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
<hr />
  <summary>
  The bounds of the source mesh this component was initialized with.
  </summary>
</li>
</ul>
<hr />
<h1 id="constructors-2"><a class="header" href="#constructors-2"><strong>Constructors</strong></a></h1>
<ul>
<li>
<h1 id="utrilerpmeshcomponent"><a class="header" href="#utrilerpmeshcomponent"><strong><code>UTrilerpMeshComponent</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 47

public:
UTrilerpMeshComponent();
</code></pre>
  <details>
  </details>
</li>
</ul>
<hr />
<h1 id="methods-5"><a class="header" href="#methods-5"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="centroid-1"><a class="header" href="#centroid-1"><strong><code>Centroid</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 166

protected:
FVector Centroid(
    FVector a,
    FVector b,
    FVector c,
    FVector d
) const;
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-8"><a class="header" href="#specifiers-8">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Computes the centroid of four points.</p>
<p>All four points are assumed to be in the same coordinate frame.</p>
  </summary>
<hr />
<h1 id="arguments-12"><a class="header" href="#arguments-12"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="a-1"><a class="header" href="#a-1"><strong><code>a</code></strong></a></h2>
<pre><code class="language-cpp">FVector a
</code></pre>
</li>
<li>
<h2 id="b-1"><a class="header" href="#b-1"><strong><code>b</code></strong></a></h2>
<pre><code class="language-cpp">FVector b
</code></pre>
</li>
<li>
<h2 id="c-1"><a class="header" href="#c-1"><strong><code>c</code></strong></a></h2>
<pre><code class="language-cpp">FVector c
</code></pre>
</li>
<li>
<h2 id="d-1"><a class="header" href="#d-1"><strong><code>d</code></strong></a></h2>
<pre><code class="language-cpp">FVector d
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-9"><a class="header" href="#returns-9"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FVector
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="debugdrawlattice-1"><a class="header" href="#debugdrawlattice-1"><strong><code>DebugDrawLattice</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 157

public:
void DebugDrawLattice(
    float Lifetime
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-9"><a class="header" href="#specifiers-9">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Visualizes the current lattice configuration.</p>
  </summary>
<hr />
<h1 id="arguments-13"><a class="header" href="#arguments-13"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="lifetime-1"><a class="header" href="#lifetime-1"><strong><code>Lifetime</code></strong></a></h2>
<pre><code class="language-cpp">float Lifetime
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="getcentroid-1"><a class="header" href="#getcentroid-1"><strong><code>GetCentroid</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 112

public:
FVector GetCentroid(
    const ELatticeFace Face
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-10"><a class="header" href="#specifiers-10">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Computes the centroid (in world-space) of the specified lattice face.</p>
  </summary>
<hr />
<h1 id="arguments-14"><a class="header" href="#arguments-14"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face-5"><a class="header" href="#face-5"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-10"><a class="header" href="#returns-10"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FVector
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="getcornersws-1"><a class="header" href="#getcornersws-1"><strong><code>GetCornersWS</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 99

public:
TArray&lt;FVector&gt; GetCornersWS() const;
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-11"><a class="header" href="#specifiers-11">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Gets the world-space positions of the Lattice corners (including offsets)</p>
  </summary>
<hr />
<h1 id="returns-11"><a class="header" href="#returns-11"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">TArray&lt;FVector&gt;
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="getsourcecornersws-1"><a class="header" href="#getsourcecornersws-1"><strong><code>GetSourceCornersWS</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 106

public:
TArray&lt;FVector&gt; GetSourceCornersWS() const;
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-12"><a class="header" href="#specifiers-12">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Gets the world-space positions of the <strong>untransformed</strong> Lattice corners.
i.e. the original/base position based on the input mesh bounds.</p>
  </summary>
<hr />
<h1 id="returns-12"><a class="header" href="#returns-12"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">TArray&lt;FVector&gt;
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="initfromdynamicmesh-1"><a class="header" href="#initfromdynamicmesh-1"><strong><code>InitFromDynamicMesh</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 78

public:
bool InitFromDynamicMesh(
    UDynamicMesh* Mesh
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-13"><a class="header" href="#specifiers-13">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Initializes the dynamic mesh from another given dynamic mesh.</p>
  </summary>
<hr />
<h1 id="arguments-15"><a class="header" href="#arguments-15"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="mesh-3"><a class="header" href="#mesh-3"><strong><code>Mesh</code></strong></a></h2>
<pre><code class="language-cpp">UDynamicMesh* Mesh
</code></pre>
<p>Mesh to copy</p>
</li>
</ul>
<hr />
<h1 id="returns-13"><a class="header" href="#returns-13"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
<p>True if copying the mesh data was successful, otherwise false</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="initfromskeletalmesh-1"><a class="header" href="#initfromskeletalmesh-1"><strong><code>InitFromSkeletalMesh</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 70

public:
bool InitFromSkeletalMesh(
    USkeletalMesh* Mesh
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-14"><a class="header" href="#specifiers-14">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Initializes the dynamic mesh from a given skeletal mesh.</p>
  </summary>
<hr />
<h1 id="arguments-16"><a class="header" href="#arguments-16"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="mesh-4"><a class="header" href="#mesh-4"><strong><code>Mesh</code></strong></a></h2>
<pre><code class="language-cpp">USkeletalMesh* Mesh
</code></pre>
<p>Mesh to copy</p>
</li>
</ul>
<hr />
<h1 id="returns-14"><a class="header" href="#returns-14"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
<p>True if copying the mesh data was successful, otherwise false</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="initfromstaticmesh-1"><a class="header" href="#initfromstaticmesh-1"><strong><code>InitFromStaticMesh</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 62

public:
bool InitFromStaticMesh(
    UStaticMesh* Mesh,
    EIncludeCollisionType IncludeCollision = EIncludeCollisionType::NONE
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-15"><a class="header" href="#specifiers-15">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Initializes the dynamic mesh from a given static mesh.</p>
  </summary>
<hr />
<h1 id="arguments-17"><a class="header" href="#arguments-17"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="mesh-5"><a class="header" href="#mesh-5"><strong><code>Mesh</code></strong></a></h2>
<pre><code class="language-cpp">UStaticMesh* Mesh
</code></pre>
<p>Mesh to copy</p>
</li>
<li>
<h2 id="includecollision"><a class="header" href="#includecollision"><strong><code>IncludeCollision</code></strong></a></h2>
<pre><code class="language-cpp">EIncludeCollisionType IncludeCollision = EIncludeCollisionType::NONE
</code></pre>
<p>Whether to copy and process the mesh's collision data as well</p>
</li>
</ul>
<hr />
<h1 id="returns-15"><a class="header" href="#returns-15"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
<p>True if copying the mesh data was successful, otherwise false</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="onregister"><a class="header" href="#onregister"><strong><code>OnRegister</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 49

public:
virtual void OnRegister() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="posteditchangechainproperty"><a class="header" href="#posteditchangechainproperty"><strong><code>PostEditChangeChainProperty</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 52

public:
virtual void PostEditChangeChainProperty(
    FPropertyChangedChainEvent&amp; PropertyChangedEvent
) override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-18"><a class="header" href="#arguments-18"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="propertychangedevent"><a class="header" href="#propertychangedevent"><strong><code>PropertyChangedEvent</code></strong></a></h2>
<pre><code class="language-cpp">FPropertyChangedChainEvent&amp; PropertyChangedEvent
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="posteditundo"><a class="header" href="#posteditundo"><strong><code>PostEditUndo</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 53

public:
virtual void PostEditUndo() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="rotateface-1"><a class="header" href="#rotateface-1"><strong><code>RotateFace</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 150

public:
void RotateFace(
    const ELatticeFace Face,
    const FRotator&amp; Rotation
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-16"><a class="header" href="#specifiers-16">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Applies a rotation to one whole side of the lattice, relative to its current
orientatoin, around the centroid of the face vertices.</p>
<p>Calls UpdateMesh.</p>
  </summary>
<hr />
<h1 id="arguments-19"><a class="header" href="#arguments-19"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face-6"><a class="header" href="#face-6"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
<li>
<h2 id="rotation-1"><a class="header" href="#rotation-1"><strong><code>Rotation</code></strong></a></h2>
<pre><code class="language-cpp">const FRotator&amp; Rotation
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="scaleface-1"><a class="header" href="#scaleface-1"><strong><code>ScaleFace</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 141

public:
void ScaleFace(
    const ELatticeFace Face,
    const FVector&amp; Scale
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-17"><a class="header" href="#specifiers-17">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Scales a face by moving its corners relative to their centroid.</p>
<p>Calls UpdateMesh.</p>
  </summary>
<hr />
<h1 id="arguments-20"><a class="header" href="#arguments-20"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face-7"><a class="header" href="#face-7"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
<li>
<h2 id="scale-1"><a class="header" href="#scale-1"><strong><code>Scale</code></strong></a></h2>
<pre><code class="language-cpp">const FVector&amp; Scale
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="setfacetranslation-1"><a class="header" href="#setfacetranslation-1"><strong><code>SetFaceTranslation</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 133

public:
void SetFaceTranslation(
    const ELatticeFace Face,
    const FVector&amp; Translation
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-18"><a class="header" href="#specifiers-18">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Sets the translation (absolute movement) of one whole side of the lattice,
relative to the base position of the vertices on that face.</p>
<p>Given translation is expected to be in world space.</p>
<p>Calls UpdateMesh.</p>
  </summary>
<hr />
<h1 id="arguments-21"><a class="header" href="#arguments-21"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face-8"><a class="header" href="#face-8"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
<li>
<h2 id="translation-1"><a class="header" href="#translation-1"><strong><code>Translation</code></strong></a></h2>
<pre><code class="language-cpp">const FVector&amp; Translation
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="setlatticews-1"><a class="header" href="#setlatticews-1"><strong><code>SetLatticeWS</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 93

public:
void SetLatticeWS(
    TArray&lt;FVector&gt; WSLattice
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-19"><a class="header" href="#specifiers-19">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Sets the lattice corners to the given world-space coordinates.</p>
  </summary>
<hr />
<h1 id="arguments-22"><a class="header" href="#arguments-22"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="wslattice-1"><a class="header" href="#wslattice-1"><strong><code>WSLattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; WSLattice
</code></pre>
<p>New lattice points, in world-space. Should have length 8.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="translateface-1"><a class="header" href="#translateface-1"><strong><code>TranslateFace</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 122

public:
void TranslateFace(
    const ELatticeFace Face,
    const FVector&amp; DeltaTranslation
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-20"><a class="header" href="#specifiers-20">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Applies a translation (relative movement) to one whole side of the lattice.</p>
<p>Given translation is expected to be in world space.</p>
<p>Calls UpdateMesh.</p>
  </summary>
<hr />
<h1 id="arguments-23"><a class="header" href="#arguments-23"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face-9"><a class="header" href="#face-9"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
<li>
<h2 id="deltatranslation"><a class="header" href="#deltatranslation"><strong><code>DeltaTranslation</code></strong></a></h2>
<pre><code class="language-cpp">const FVector&amp; DeltaTranslation
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="updatemesh-1"><a class="header" href="#updatemesh-1"><strong><code>UpdateMesh</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilerpMeshComponent.h : 86

public:
void UpdateMesh();
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-21"><a class="header" href="#specifiers-21">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Updates the underlying mesh data to match the current Lattice configuration.</p>
<p>Should be called whenever Lattice has been modified to keep the mesh up-to-date.</p>
  </summary>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
