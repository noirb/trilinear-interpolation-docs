<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>NB Trilinear Mesh Interpolation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NB Trilinear Mesh Interpolation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="contents"><a class="header" href="#contents">Contents</a></h1>
<ul>
<li><a href="/reference.html">C++ API Reference</a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage--examples"><a class="header" href="#usage--examples">Usage &amp; Examples</a></h1>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<p>The basic idea behind Trilinear Mesh Interpolation is this: enclose your mesh in a box (typically referred to here as the <code>Lattice</code>). The default state of the
box essentially matches the mesh's bounding box. When the corners of the box are moved, the mesh deforms to move with it, with vertices close to the moved corner
moving about the same as the corner and vertices far from the moved corner not being affected at all. Vertices will always move to maintain their position within
the lattice, relative to each corner.</p>
<p>Lattice values are treated as offsets. If the lattice corners all have the value <code>(0,0,0)</code>, then the mesh will be untransformed and will appear in its original state.</p>
<h2 id="two-approaches-to-interpolation"><a class="header" href="#two-approaches-to-interpolation">Two Approaches to Interpolation</a></h2>
<p>This plugin provides two approaches to trilinear interpolation. Visually, they will produce the same results, but which approach you should prefer to use may
depend on your use case.</p>
<h3 id="wpo-based-material-shader"><a class="header" href="#wpo-based-material-shader"><a href="how-to/./trilerp-materials.html">WPO-Based Material Shader</a></a></h3>
<p>The trilinear interpolation can be performed entirely in a shader, allowing for the effect to be performed on the GPU.</p>
<p>This is very fast, and can be used on meshes with a high vertex count and can support a large number of meshes all deforming together in a scene at real-time.
However, the effect is purely visual, the collision geometry of the mesh, etc., is unchanged.</p>
<p>If you need to animate the effect, particularly if you need a LOT of objects all bouncing and twisting around in a scene together, this is the recommended approach.</p>
<p>If you just need to apply the effect once, for example in-editor or during a procedural level generation step, or if you need collision geometry to match the
deformed mesh, then you should use the DynamicMesh-based approach.</p>
<h3 id="dynamicmesh"><a class="header" href="#dynamicmesh"><a href="how-to/./trilerp-mesh.html">DynamicMesh</a></a></h3>
<p>In this approach, the trilinear interpolation is performed on the CPU to modify a given mesh. The underlying C++ code has been optimized to parallelize this work
where possible, so you can still use this to perform real-time deformation on detailed meshes or on a number of simple meshes in a scene, but performance will be
limited by the total number of vertices you need to process in a given frame.</p>
<p>But, because we are processing the mesh data on the CPU we can also process a mesh's <em>collision</em> data, so you can use this to tweak the angle of a slope and then
have your character walk on it.</p>
<p>This approach is best used sparingly or on meshes which only need to be deformed once (e.g. in-editor or as part of a procedural level generation step).</p>
<h1 id="pages"><a class="header" href="#pages">Pages</a></h1>
<ul>
<li><a href="how-to//how-to/trilerp-materials.html">Trilinear Interpolation Materials</a></li>
<li><a href="how-to//how-to/trilerp-mesh.html">Trilinear Interpolated Dynamic Meshes</a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trilinear-interpolation-materials"><a class="header" href="#trilinear-interpolation-materials">Trilinear Interpolation Materials</a></h1>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>The interpolation functionality is encapsulated in a single Material Function, which can be found under <code>NB - Interpolation &gt; Trilinear Interpolation</code></p>
<p><img src="how-to/../assets/tutorial/mf-trilerp-node.png" alt="" /></p>
<p>The Inputs are: A point or position you wish to transform (usually just the absolute world position), 8 <code>Cube_XX</code> values, which define the lattice offsets,
and the original (untransformed, scaled, or otherwise modified) bounds of the mesh you wish to transform.</p>
<p>It will output a <code>float3</code>, which can be directly used to drive the <code>World Position Offset</code> in your material.</p>
<p>The <code>Cube_XX</code> values refer to the corners of the lattice used to deform the mesh, with the first four values (<code>X0</code>)
defining the bottom four corners of the lattice and the last four (<code>X1</code>) defining the top four corners:</p>
<p><img src="how-to/../assets/tutorial/lattice-corners-shader.png" alt="" /></p>
<p>A complete example in which all interpolation values are driven by parameters (e.g. so you can manually adjust them in a blueprint):</p>
<p><img src="how-to/../assets/tutorial/trilerp-mat-example.png" alt="" /></p>
<p>Because we are using the <code>Absolute World Position</code> as the position to transform, we need to ensure that <code>MinBound</code> and <code>MaxBound</code> values are also in world coordinates.
This can be done easily using <code>Get Actor Bounds</code> in the blueprint passing this information to the material:
<img src="how-to/../assets/tutorial/trilerp-mat-example_bp-bounds.png" alt="" /></p>
<p>This is usually the most straightforward approach, but if for some reason you are not working in world coordinates it is important to remember that the bounds and the
point passed in for transformation must be in the same coordinate frame.</p>
<p>If you just intend to use the interpolation to make your object a little jiggly or bounce in response to some other material parameter, though, it's not necessary to expose
these values as parameters, you can drive them entirely within your material.</p>
<p>For example, the following material will move <strong>only</strong> the top of the lattice over time, causing the mesh to stretch up and down vertically. Because the bottom of the lattice is not
being changed, the base of the mesh will remain fixed in place, allowing for a bouncy animation without the mesh moving off of the ground. This allows you a lot of freedom to
stretch and twist the mesh as you want, while still being able to constrain it to keep one side fixed in place.</p>
<p><img src="how-to/../assets/tutorial/trilerp-mat-example_bounce.png" alt="" /></p>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<h3 id="bounds-scale"><a class="header" href="#bounds-scale">Bounds Scale</a></h3>
<p>If you use <code>World Position Offset</code> to create a large deformation in an object, this can lead to some very ugly shadow artifacts:
<img src="how-to/../assets/tutorial/wpo-bounds-scale-shadow-error.png" alt="" /></p>
<p>This can be fixed by increasing the bounds scale:
<img src="how-to/../assets/tutorial/wpo-bounds-scale-fix.png" alt="" /></p>
<p>But, depending on how you are computing the original mesh bounds you may notice that this changes the effect of the Trilinear interpolation!
(notice the bottom corners of the cube above are no longer correctly aligned with the ground)
If you are NOT passing the original (unscaled) object bounds as a material parameter but are relying on one of the <code>Object Bounds</code> or <code>Object Local Bounds</code> nodes, then you
will need to compensate for the bounds scale in the material. If you know you will always use a constant bounds scale you can use a constant value in the material,
or you can use a paramter to allow it to be set by an actor blueprint any time the bounds scale is changed or set to a fixed value in different material instances:</p>
<p><img src="how-to/../assets/tutorial/wpo-bounds-scale-fix-mat.png" alt="" />
In this example, we are using a parameter which is expected to be the <strong>inverse</strong> of the bounds scale, so if the bounds scale is set to <code>2.0</code> this parameter should be
set to <code>0.5</code>. This avoids the possibility of dividing by zero by mistake, but it would also work to use the bounds scale directly and replace the multiply node with
a divide.</p>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trilinear-interpolation-with-dynamicmesh"><a class="header" href="#trilinear-interpolation-with-dynamicmesh">Trilinear Interpolation With DynamicMesh</a></h1>
<p>The functionality for deforming DynamicMeshes is contained within the <strong>UTrilinearInterpolatedMeshComponent</strong>.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<h2 id="handling-collision-data"><a class="header" href="#handling-collision-data">Handling Collision Data</a></h2>
<h2 id="a-note-on-dynamicmeshactor"><a class="header" href="#a-note-on-dynamicmeshactor">A Note on DynamicMeshActor</a></h2>
<p>The <a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/BlueprintAPI/DynamicMeshActor">DynamicMeshActor</a> provides
a lot of additional functionality which is useful for working with DynamicMeshes. This functionality isn't required to use
the <code>TrilinearInterpolatedMeshComponent</code>, but if you are doing some of your own mesh modification/generation you may want to
use them together.</p>
<p>Fortunately, it is possible to replace the <code>DynamicMeshComponent</code> on a <code>DynamicMeshActor</code> with a <code>TrilinearInterpolatedMeshComponent</code>.
You can find the <code>Component Class</code> dropdown in the <code>DynamicMeshActor</code> details panel:
<img src="how-to/../assets/tutorial/dynamic-mesh-comp-type-setting.png" alt="" /></p>
<p>You then just need to cast to <code>TrilinearInterpolatedMeshComponent</code> in your actor blueprint:
<img src="how-to/../assets/tutorial/dynamic-mesh-comp-cast.png" alt="" /></p>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-api-reference"><a class="header" href="#c-api-reference">C++ API Reference</a></h1>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<ul>
<li><a href="/reference/enums/EIncludeCollisionType.html"><code>EIncludeCollisionType</code></a></li>
<li><a href="/reference/enums/ELatticeFace.html"><code>ELatticeFace</code></a></li>
</ul>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<ul>
<li><a href="/reference/structs/HNBLatticeCornerProxy.html"><code>HNBLatticeCornerProxy</code></a></li>
<li><a href="/reference/structs/HNBLatticeFaceProxy.html"><code>HNBLatticeFaceProxy</code></a></li>
</ul>
<h2 id="classes"><a class="header" href="#classes">Classes</a></h2>
<ul>
<li><a href="/reference/classes/FNBTrilinearInterpolationEditorModule.html"><code>FNBTrilinearInterpolationEditorModule</code></a></li>
<li><a href="/reference/classes/FNBTrilinearInterpolationModule.html"><code>FNBTrilinearInterpolationModule</code></a></li>
<li><a href="/reference/classes/NBTrilinearVisualizer.html"><code>NBTrilinearVisualizer</code></a></li>
<li><a href="/reference/classes/UNBTrilinearInterpolation.html"><code>UNBTrilinearInterpolation</code></a></li>
<li><a href="/reference/classes/UNBTrilinearInterpolationBPLibrary.html"><code>UNBTrilinearInterpolationBPLibrary</code></a></li>
<li><a href="/reference/classes/UTrilinearInterpolatedMeshComponent.html"><code>UTrilinearInterpolatedMeshComponent</code></a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-1"><a class="header" href="#enums-1">Enums</a></h1>
<ul>
<li><a href="reference//reference/reference/enums/EIncludeCollisionType.html"><code>EIncludeCollisionType</code></a></li>
<li><a href="reference//reference/reference/enums/ELatticeFace.html"><code>ELatticeFace</code></a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-eincludecollisiontype"><a class="header" href="#enum-eincludecollisiontype"><strong>Enum: <code>EIncludeCollisionType</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 28

enum class EIncludeCollisionType : uint8 {
    NONE    = 0 UMETA(DisplayName = "None"),
    SIMPLE  = 1 UMETA(DisplayName = "Simple"),
    COMPLEX = 2 UMETA(DisplayName = "Complex")
};
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers"><a class="header" href="#specifiers">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Which type of collision mesh to use/generate when
updating a deformed mesh.</p>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum-elatticeface"><a class="header" href="#enum-elatticeface"><strong>Enum: <code>ELatticeFace</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 13

enum class ELatticeFace : uint8 {
    BOTTOM = 0 UMETA(DisplayName = "Bottom"),
    TOP    = 1 UMETA(DisplayName = "Top"),
    SOUTH  = 2 UMETA(DisplayName = "South"),
    NORTH  = 3 UMETA(DisplayName = "North"),
    WEST   = 4 UMETA(DisplayName = "West"),
    EAST   = 5 UMETA(DisplayName = "East"),
    NONE   = 6
};
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-1"><a class="header" href="#specifiers-1">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintType</strong></li>
</ul>
<hr />
<p>Represents the faces of a deformation lattice.</p>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-1"><a class="header" href="#structs-1">Structs</a></h1>
<ul>
<li><a href="reference//reference/reference/structs/HNBLatticeCornerProxy.html"><code>HNBLatticeCornerProxy</code></a></li>
<li><a href="reference//reference/reference/structs/HNBLatticeFaceProxy.html"><code>HNBLatticeFaceProxy</code></a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-hnblatticecornerproxy"><a class="header" href="#struct-hnblatticecornerproxy"><strong>Struct: <code>HNBLatticeCornerProxy</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 30

struct HNBLatticeCornerProxy
    : public HComponentVisProxy;
</code></pre>
<hr />
<p>Hit proxy for handling input on lattice corners</p>
<hr />
<h1 id="properties"><a class="header" href="#properties"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="latticeid"><a class="header" href="#latticeid"><strong><code>LatticeID</code></strong></a></h1>
<pre><code class="language-cpp">public:
int32 LatticeID;
</code></pre>
<hr />
</li>
</ul>
<hr />
<h1 id="constructors"><a class="header" href="#constructors"><strong>Constructors</strong></a></h1>
<ul>
<li>
<h1 id="hnblatticecornerproxy"><a class="header" href="#hnblatticecornerproxy"><strong><code>HNBLatticeCornerProxy</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 35

public:
HNBLatticeCornerProxy(
    const UActorComponent* InComponent,
    int32 LatticeID
);
</code></pre>
  <details>
<hr />
<h1 id="arguments"><a class="header" href="#arguments"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="incomponent"><a class="header" href="#incomponent"><strong><code>InComponent</code></strong></a></h2>
<pre><code class="language-cpp">const UActorComponent* InComponent
</code></pre>
</li>
<li>
<h2 id="latticeid-1"><a class="header" href="#latticeid-1"><strong><code>LatticeID</code></strong></a></h2>
<pre><code class="language-cpp">int32 LatticeID
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-hnblatticefaceproxy"><a class="header" href="#struct-hnblatticefaceproxy"><strong>Struct: <code>HNBLatticeFaceProxy</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 17

struct HNBLatticeFaceProxy
    : public HComponentVisProxy;
</code></pre>
<hr />
<p>Hit proxy for handling input on lattice faces</p>
<hr />
<h1 id="properties-1"><a class="header" href="#properties-1"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="faceid"><a class="header" href="#faceid"><strong><code>FaceID</code></strong></a></h1>
<pre><code class="language-cpp">public:
ELatticeFace FaceID;
</code></pre>
<hr />
</li>
</ul>
<hr />
<h1 id="constructors-1"><a class="header" href="#constructors-1"><strong>Constructors</strong></a></h1>
<ul>
<li>
<h1 id="hnblatticefaceproxy"><a class="header" href="#hnblatticefaceproxy"><strong><code>HNBLatticeFaceProxy</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 22

public:
HNBLatticeFaceProxy(
    const UActorComponent* InComponent,
    ELatticeFace FaceID
);
</code></pre>
  <details>
<hr />
<h1 id="arguments-1"><a class="header" href="#arguments-1"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="incomponent-1"><a class="header" href="#incomponent-1"><strong><code>InComponent</code></strong></a></h2>
<pre><code class="language-cpp">const UActorComponent* InComponent
</code></pre>
</li>
<li>
<h2 id="faceid-1"><a class="header" href="#faceid-1"><strong><code>FaceID</code></strong></a></h2>
<pre><code class="language-cpp">ELatticeFace FaceID
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="classes-1"><a class="header" href="#classes-1">Classes</a></h1>
<ul>
<li><a href="reference//reference/reference/classes/FNBTrilinearInterpolationEditorModule.html"><code>FNBTrilinearInterpolationEditorModule</code></a></li>
<li><a href="reference//reference/reference/classes/FNBTrilinearInterpolationModule.html"><code>FNBTrilinearInterpolationModule</code></a></li>
<li><a href="reference//reference/reference/classes/NBTrilinearVisualizer.html"><code>NBTrilinearVisualizer</code></a></li>
<li><a href="reference//reference/reference/classes/UNBTrilinearInterpolation.html"><code>UNBTrilinearInterpolation</code></a></li>
<li><a href="reference//reference/reference/classes/UNBTrilinearInterpolationBPLibrary.html"><code>UNBTrilinearInterpolationBPLibrary</code></a></li>
<li><a href="reference//reference/reference/classes/UTrilinearInterpolatedMeshComponent.html"><code>UTrilinearInterpolatedMeshComponent</code></a></li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-fnbtrilinearinterpolationeditormodule"><a class="header" href="#class-fnbtrilinearinterpolationeditormodule"><strong>Class: <code>FNBTrilinearInterpolationEditorModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationEditorModule.h : 14

class FNBTrilinearInterpolationEditorModule
    : public IModuleInterface;
</code></pre>
<hr />
<p>Editor module for supporting improved visualization and editor tools
related to Trilinear Mesh Interpoloation</p>
<hr />
<h1 id="methods"><a class="header" href="#methods"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="shutdownmodule"><a class="header" href="#shutdownmodule"><strong><code>ShutdownModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationEditorModule.h : 18

public:
virtual void ShutdownModule() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="startupmodule"><a class="header" href="#startupmodule"><strong><code>StartupModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationEditorModule.h : 17

public:
virtual void StartupModule() override;
</code></pre>
  <details>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-fnbtrilinearinterpolationmodule"><a class="header" href="#class-fnbtrilinearinterpolationmodule"><strong>Class: <code>FNBTrilinearInterpolationModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationModule.h : 10

class FNBTrilinearInterpolationModule
    : public IModuleInterface;
</code></pre>
<hr />
<p>Runtime module for Trilinear Interpolation support</p>
<hr />
<h1 id="methods-1"><a class="header" href="#methods-1"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="shutdownmodule-1"><a class="header" href="#shutdownmodule-1"><strong><code>ShutdownModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationModule.h : 16

public:
virtual void ShutdownModule() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="startupmodule-1"><a class="header" href="#startupmodule-1"><strong><code>StartupModule</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationModule.h : 15

public:
virtual void StartupModule() override;
</code></pre>
  <details>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-nbtrilinearvisualizer"><a class="header" href="#class-nbtrilinearvisualizer"><strong>Class: <code>NBTrilinearVisualizer</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 47

class NBTrilinearVisualizer
    : public FComponentVisualizer;
</code></pre>
<hr />
<p>Responsible for showing the lattice configuration and editing widgets on a <a href="reference/classes//reference/classes/UTrilinearInterpolatedMeshComponent.html"><strong><code>UTrilinearInterpolatedMeshComponent</code></strong></a>
when it's selected in-editor.</p>
<p>Allows the user to freely edit the lattice through regular translation/rotation/scale controls rather than needing to
enter corner offsets manually.</p>
<hr />
<h1 id="methods-2"><a class="header" href="#methods-2"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="drawvisualization"><a class="header" href="#drawvisualization"><strong><code>DrawVisualization</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 50

public:
virtual void DrawVisualization(
    const UActorComponent* Component,
    const FSceneView* View,
    FPrimitiveDrawInterface* PDI
) override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-2"><a class="header" href="#arguments-2"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="component"><a class="header" href="#component"><strong><code>Component</code></strong></a></h2>
<pre><code class="language-cpp">const UActorComponent* Component
</code></pre>
</li>
<li>
<h2 id="view"><a class="header" href="#view"><strong><code>View</code></strong></a></h2>
<pre><code class="language-cpp">const FSceneView* View
</code></pre>
</li>
<li>
<h2 id="pdi"><a class="header" href="#pdi"><strong><code>PDI</code></strong></a></h2>
<pre><code class="language-cpp">FPrimitiveDrawInterface* PDI
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="endediting"><a class="header" href="#endediting"><strong><code>EndEditing</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 54

public:
virtual void EndEditing() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="getwidgetlocation"><a class="header" href="#getwidgetlocation"><strong><code>GetWidgetLocation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 52

public:
virtual bool GetWidgetLocation(
    const FEditorViewportClient* ViewportClient,
    FVector&amp; OutLocation
) const override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-3"><a class="header" href="#arguments-3"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="viewportclient"><a class="header" href="#viewportclient"><strong><code>ViewportClient</code></strong></a></h2>
<pre><code class="language-cpp">const FEditorViewportClient* ViewportClient
</code></pre>
</li>
<li>
<h2 id="outlocation"><a class="header" href="#outlocation"><strong><code>OutLocation</code></strong></a></h2>
<pre><code class="language-cpp">FVector&amp; OutLocation
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns"><a class="header" href="#returns"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="handleinputdelta"><a class="header" href="#handleinputdelta"><strong><code>HandleInputDelta</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 53

public:
virtual bool HandleInputDelta(
    FEditorViewportClient* ViewportClient,
    FViewport* Viewport,
    FVector&amp; DeltaTranslate,
    FRotator&amp; DeltaRotate,
    FVector&amp; DeltaScale
) override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-4"><a class="header" href="#arguments-4"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="viewportclient-1"><a class="header" href="#viewportclient-1"><strong><code>ViewportClient</code></strong></a></h2>
<pre><code class="language-cpp">FEditorViewportClient* ViewportClient
</code></pre>
</li>
<li>
<h2 id="viewport"><a class="header" href="#viewport"><strong><code>Viewport</code></strong></a></h2>
<pre><code class="language-cpp">FViewport* Viewport
</code></pre>
</li>
<li>
<h2 id="deltatranslate"><a class="header" href="#deltatranslate"><strong><code>DeltaTranslate</code></strong></a></h2>
<pre><code class="language-cpp">FVector&amp; DeltaTranslate
</code></pre>
</li>
<li>
<h2 id="deltarotate"><a class="header" href="#deltarotate"><strong><code>DeltaRotate</code></strong></a></h2>
<pre><code class="language-cpp">FRotator&amp; DeltaRotate
</code></pre>
</li>
<li>
<h2 id="deltascale"><a class="header" href="#deltascale"><strong><code>DeltaScale</code></strong></a></h2>
<pre><code class="language-cpp">FVector&amp; DeltaScale
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-1"><a class="header" href="#returns-1"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="visproxyhandleclick"><a class="header" href="#visproxyhandleclick"><strong><code>VisProxyHandleClick</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationVisualizer.h : 51

public:
virtual bool VisProxyHandleClick(
    FEditorViewportClient* InViewportClient,
    HComponentVisProxy* VisProxy,
    const FViewportClick&amp; Click
) override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-5"><a class="header" href="#arguments-5"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="inviewportclient"><a class="header" href="#inviewportclient"><strong><code>InViewportClient</code></strong></a></h2>
<pre><code class="language-cpp">FEditorViewportClient* InViewportClient
</code></pre>
</li>
<li>
<h2 id="visproxy"><a class="header" href="#visproxy"><strong><code>VisProxy</code></strong></a></h2>
<pre><code class="language-cpp">HComponentVisProxy* VisProxy
</code></pre>
</li>
<li>
<h2 id="click"><a class="header" href="#click"><strong><code>Click</code></strong></a></h2>
<pre><code class="language-cpp">const FViewportClick&amp; Click
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-2"><a class="header" href="#returns-2"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-unbtrilinearinterpolation"><a class="header" href="#class-unbtrilinearinterpolation"><strong>Class: <code>UNBTrilinearInterpolation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolation.h : 9

class UNBTrilinearInterpolation;
</code></pre>
<hr />
<hr />
<h1 id="methods-3"><a class="header" href="#methods-3"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="tinterp"><a class="header" href="#tinterp"><strong><code>TInterp</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolation.h : 44

public:
static FVector TInterp(
    FVector Point,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound
);
</code></pre>
  <details>
  <summary>
<p>Performs trilinear interpolation on a single point</p>
  </summary>
<hr />
<h1 id="arguments-6"><a class="header" href="#arguments-6"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="point"><a class="header" href="#point"><strong><code>Point</code></strong></a></h2>
<pre><code class="language-cpp">FVector Point
</code></pre>
<p>Point to transform</p>
</li>
<li>
<h2 id="lattice"><a class="header" href="#lattice"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>The corners of the lattice to use for deformation. Should have length 8.</p>
</li>
<li>
<h2 id="minbound"><a class="header" href="#minbound"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>Minimum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="maxbound"><a class="header" href="#maxbound"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>Maximum X,Y,Z of the target mesh's bounding box</p>
</li>
</ul>
<hr />
<h1 id="returns-3"><a class="header" href="#returns-3"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FVector
</code></pre>
<p>Transformed point</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="trilinearinterpolation"><a class="header" href="#trilinearinterpolation"><strong><code>TrilinearInterpolation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolation.h : 22

public:
static UDynamicMesh* TrilinearInterpolation(
    UDynamicMesh* TargetMesh,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound,
    FVector origin
);
</code></pre>
  <details>
  <summary>
<p>Performs trilinear interpolation on the given DynamicMesh.
The mesh should be in its original, undeformed state.</p>
  </summary>
<hr />
<h1 id="arguments-7"><a class="header" href="#arguments-7"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="targetmesh"><a class="header" href="#targetmesh"><strong><code>TargetMesh</code></strong></a></h2>
<pre><code class="language-cpp">UDynamicMesh* TargetMesh
</code></pre>
<p>Mesh to deform</p>
</li>
<li>
<h2 id="lattice-1"><a class="header" href="#lattice-1"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>The corners of the lattice to use for deformation. Should have length 8.</p>
</li>
<li>
<h2 id="minbound-1"><a class="header" href="#minbound-1"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>Minimum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="maxbound-1"><a class="header" href="#maxbound-1"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>Maximum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="origin"><a class="header" href="#origin"><strong><code>origin</code></strong></a></h2>
<pre><code class="language-cpp">FVector origin
</code></pre>
<p>Origin the mesh's vertices are relative to</p>
</li>
</ul>
<hr />
<h1 id="returns-4"><a class="header" href="#returns-4"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">UDynamicMesh*
</code></pre>
<p>The transformed mesh</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="trilinearinterpolation-1"><a class="header" href="#trilinearinterpolation-1"><strong><code>TrilinearInterpolation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolation.h : 34

public:
static FGeometryScriptVectorList TrilinearInterpolation(
    FGeometryScriptVectorList Vertices,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound,
    FVector origin
);
</code></pre>
  <details>
  <summary>
<p>Performs trilinear interpolation on a set of vertices.
The vertices should be in their original, undeformed state.</p>
  </summary>
<hr />
<h1 id="arguments-8"><a class="header" href="#arguments-8"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="vertices"><a class="header" href="#vertices"><strong><code>Vertices</code></strong></a></h2>
<pre><code class="language-cpp">FGeometryScriptVectorList Vertices
</code></pre>
<p>Vertices to transform</p>
</li>
<li>
<h2 id="lattice-2"><a class="header" href="#lattice-2"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>The corners of the lattice to use for deformation. Should have length 8.</p>
</li>
<li>
<h2 id="minbound-2"><a class="header" href="#minbound-2"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>Minimum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="maxbound-2"><a class="header" href="#maxbound-2"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>Maximum X,Y,Z of the target mesh's bounding box</p>
</li>
<li>
<h2 id="origin-1"><a class="header" href="#origin-1"><strong><code>origin</code></strong></a></h2>
<pre><code class="language-cpp">FVector origin
</code></pre>
<p>Origin the mesh's vertices are relative to</p>
</li>
</ul>
<hr />
<h1 id="returns-5"><a class="header" href="#returns-5"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FGeometryScriptVectorList
</code></pre>
<p>The transformed vertices</p>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-unbtrilinearinterpolationbplibrary"><a class="header" href="#class-unbtrilinearinterpolationbplibrary"><strong>Class: <code>UNBTrilinearInterpolationBPLibrary</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationBPLibrary.h : 13

class UNBTrilinearInterpolationBPLibrary
    : public UBlueprintFunctionLibrary;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<hr />
<hr />
<h1 id="methods-4"><a class="header" href="#methods-4"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="tinterp-1"><a class="header" href="#tinterp-1"><strong><code>TInterp</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationBPLibrary.h : 58

public:
static FVector TInterp(
    FVector Point,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-2"><a class="header" href="#specifiers-2">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBMeshTools</em></li>
</ul>
<h3 id="meta-specifiers"><a class="header" href="#meta-specifiers">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Trilinear Interpolation (point)</em></li>
<li><strong>Keywords</strong> = <em>Trilinear Interpolation</em></li>
</ul>
  <summary>
<p>Performs trilinear interpolation on a single point.</p>
<p>This may be useful if instead of transforming a mesh you are transforming something like a color.</p>
  </summary>
<hr />
<h1 id="arguments-9"><a class="header" href="#arguments-9"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="point-1"><a class="header" href="#point-1"><strong><code>Point</code></strong></a></h2>
<pre><code class="language-cpp">FVector Point
</code></pre>
</li>
<li>
<h2 id="lattice-3"><a class="header" href="#lattice-3"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>List of offsets for the corners of the lattice cube. A value of 0 will result in no change. MUST contain 8 entries!</p>
</li>
<li>
<h2 id="minbound-3"><a class="header" href="#minbound-3"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>The minimum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="maxbound-3"><a class="header" href="#maxbound-3"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>The maximum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
</ul>
<hr />
<h1 id="returns-6"><a class="header" href="#returns-6"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FVector
</code></pre>
<p>The transformed point</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="trilinearinterpolation-2"><a class="header" href="#trilinearinterpolation-2"><strong><code>TrilinearInterpolation</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationBPLibrary.h : 31

public:
static FGeometryScriptVectorList TrilinearInterpolation(
    FGeometryScriptVectorList Vertices,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound,
    FVector Origin
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-3"><a class="header" href="#specifiers-3">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBMeshTools</em></li>
</ul>
<h3 id="meta-specifiers-1"><a class="header" href="#meta-specifiers-1">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Trilinear Interpolation (vertices)</em></li>
<li><strong>Keywords</strong> = <em>Trilinear Interpolation</em></li>
</ul>
  <summary>
<p>Performs trilinear interpolation on the provided list of vertices.</p>
<p>If the required inputs are invalid, the original list of vertices will be returned unmodified.</p>
  </summary>
<hr />
<h1 id="arguments-10"><a class="header" href="#arguments-10"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="vertices-1"><a class="header" href="#vertices-1"><strong><code>Vertices</code></strong></a></h2>
<pre><code class="language-cpp">FGeometryScriptVectorList Vertices
</code></pre>
<p>List of vertices to transform.</p>
</li>
<li>
<h2 id="lattice-4"><a class="header" href="#lattice-4"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>List of offsets for the corners of the lattice cube. A value of 0 will result in no change. MUST contain 8 entries!</p>
</li>
<li>
<h2 id="minbound-4"><a class="header" href="#minbound-4"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>The minimum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="maxbound-4"><a class="header" href="#maxbound-4"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>The maximum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="origin-2"><a class="header" href="#origin-2"><strong><code>Origin</code></strong></a></h2>
<pre><code class="language-cpp">FVector Origin
</code></pre>
<p>The origin of the mesh the vertices are from. Many meshes may have an origin which is not the same as their pivot.</p>
</li>
</ul>
<hr />
<h1 id="returns-7"><a class="header" href="#returns-7"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FGeometryScriptVectorList
</code></pre>
<p>Transformed vertices. If the inputs are invalid (e.g., Latice is empty) then the original given vertices will be returned unmodified.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="trilinearinterpolation2"><a class="header" href="#trilinearinterpolation2"><strong><code>TrilinearInterpolation2</code></strong></a></h1>
<pre><code class="language-cpp">//  NBTrilinearInterpolationBPLibrary.h : 45

public:
static UDynamicMesh* TrilinearInterpolation2(
    UDynamicMesh* TargetMesh,
    TArray&lt;FVector&gt; Lattice,
    FVector MinBound,
    FVector MaxBound,
    FVector origin
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-4"><a class="header" href="#specifiers-4">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBMeshTools</em></li>
</ul>
<h3 id="meta-specifiers-2"><a class="header" href="#meta-specifiers-2">Meta Specifiers:</a></h3>
<ul>
<li><strong>DisplayName</strong> = <em>Trilinear Interpolation (mesh)</em></li>
<li><strong>Keywords</strong> = <em>Trilinear Interpolation</em></li>
</ul>
  <summary>
<p>Performs trilinear interpolation on the provided dynamic mesh.</p>
<p>If the required inputs are invalid, the original mesh will be returned unmodified.</p>
  </summary>
<hr />
<h1 id="arguments-11"><a class="header" href="#arguments-11"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="targetmesh-1"><a class="header" href="#targetmesh-1"><strong><code>TargetMesh</code></strong></a></h2>
<pre><code class="language-cpp">UDynamicMesh* TargetMesh
</code></pre>
<p>Mesh to transform.</p>
</li>
<li>
<h2 id="lattice-5"><a class="header" href="#lattice-5"><strong><code>Lattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; Lattice
</code></pre>
<p>List of offsets for the corners of the lattice cube. A value of 0 will result in no change. MUST contain 8 entries!</p>
</li>
<li>
<h2 id="minbound-5"><a class="header" href="#minbound-5"><strong><code>MinBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MinBound
</code></pre>
<p>The minimum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="maxbound-5"><a class="header" href="#maxbound-5"><strong><code>MaxBound</code></strong></a></h2>
<pre><code class="language-cpp">FVector MaxBound
</code></pre>
<p>The maximum corner of the bounding box for the provided vertices (i.e. the mesh bounds the vertices came from)</p>
</li>
<li>
<h2 id="origin-3"><a class="header" href="#origin-3"><strong><code>origin</code></strong></a></h2>
<pre><code class="language-cpp">FVector origin
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-8"><a class="header" href="#returns-8"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">UDynamicMesh*
</code></pre>
<p>The transformed mesh. If the inputs are invalid (e.g., Lattice is empty) then the original mesh will be returned unmodified.</p>
</li>
</ul>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class-utrilinearinterpolatedmeshcomponent"><a class="header" href="#class-utrilinearinterpolatedmeshcomponent"><strong>Class: <code>UTrilinearInterpolatedMeshComponent</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 40

class NBTRILINEARINTERPOLATION_API UTrilinearInterpolatedMeshComponent
    : public UDynamicMeshComponent;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-5"><a class="header" href="#specifiers-5">Specifiers:</a></h3>
<ul>
<li><strong>ClassGroup</strong> = <em>Rendering</em></li>
</ul>
<h3 id="meta-specifiers-3"><a class="header" href="#meta-specifiers-3">Meta Specifiers:</a></h3>
<ul>
<li><strong>BlueprintSpawnableComponent</strong></li>
</ul>
<hr />
<p>A DynamicMeshComponent which supports trilinear interpolation of the
underlying mesh.</p>
<hr />
<h1 id="properties-2"><a class="header" href="#properties-2"><strong>Properties</strong></a></h1>
<ul>
<li>
<h1 id="lattice-6"><a class="header" href="#lattice-6"><strong><code>Lattice</code></strong></a></h1>
<pre><code class="language-cpp">public:
TArray&lt;FVector&gt; Lattice;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-6"><a class="header" href="#specifiers-6">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadWrite</strong></li>
<li><strong>EditAnywhere</strong></li>
<li><strong>EditFixedSize</strong></li>
</ul>
<hr />
  <summary>
  Offsets from interpolation lattice corners. Do not modify length.
<p>First four values represent the bottom four corners, second four the
top four corners.</p>
<p>Because this is a list of offsets, if all vectors are zero the trilinear interpolation
will not modify the mesh, it will just return the original vertex positions.</p>
  </summary>
</li>
<li>
<h1 id="sourcebounds"><a class="header" href="#sourcebounds"><strong><code>SourceBounds</code></strong></a></h1>
<pre><code class="language-cpp">public:
FBoxSphereBounds SourceBounds;
</code></pre>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-7"><a class="header" href="#specifiers-7">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintReadOnly</strong></li>
</ul>
<hr />
  <summary>
  The bounds of the source mesh this component was initialized with.
  </summary>
</li>
</ul>
<hr />
<h1 id="constructors-2"><a class="header" href="#constructors-2"><strong>Constructors</strong></a></h1>
<ul>
<li>
<h1 id="utrilinearinterpolatedmeshcomponent"><a class="header" href="#utrilinearinterpolatedmeshcomponent"><strong><code>UTrilinearInterpolatedMeshComponent</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 46

public:
UTrilinearInterpolatedMeshComponent();
</code></pre>
  <details>
  </details>
</li>
</ul>
<hr />
<h1 id="methods-5"><a class="header" href="#methods-5"><strong>Methods</strong></a></h1>
<ul>
<li>
<h1 id="centroid"><a class="header" href="#centroid"><strong><code>Centroid</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 164

protected:
FVector Centroid(
    FVector a,
    FVector b,
    FVector c,
    FVector d
) const;
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-8"><a class="header" href="#specifiers-8">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Computes the centroid of four points.</p>
<p>All four points are assumed to be in the same coordinate frame.</p>
  </summary>
<hr />
<h1 id="arguments-12"><a class="header" href="#arguments-12"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="a"><a class="header" href="#a"><strong><code>a</code></strong></a></h2>
<pre><code class="language-cpp">FVector a
</code></pre>
</li>
<li>
<h2 id="b"><a class="header" href="#b"><strong><code>b</code></strong></a></h2>
<pre><code class="language-cpp">FVector b
</code></pre>
</li>
<li>
<h2 id="c"><a class="header" href="#c"><strong><code>c</code></strong></a></h2>
<pre><code class="language-cpp">FVector c
</code></pre>
</li>
<li>
<h2 id="d"><a class="header" href="#d"><strong><code>d</code></strong></a></h2>
<pre><code class="language-cpp">FVector d
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-9"><a class="header" href="#returns-9"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FVector
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="debugdrawlattice"><a class="header" href="#debugdrawlattice"><strong><code>DebugDrawLattice</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 155

public:
void DebugDrawLattice(
    float Lifetime
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-9"><a class="header" href="#specifiers-9">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Visualizes the current lattice configuration.</p>
  </summary>
<hr />
<h1 id="arguments-13"><a class="header" href="#arguments-13"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="lifetime"><a class="header" href="#lifetime"><strong><code>Lifetime</code></strong></a></h2>
<pre><code class="language-cpp">float Lifetime
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="getcentroid"><a class="header" href="#getcentroid"><strong><code>GetCentroid</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 110

public:
FVector GetCentroid(
    const ELatticeFace Face
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-10"><a class="header" href="#specifiers-10">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Computes the centroid (in world-space) of the specified lattice face.</p>
  </summary>
<hr />
<h1 id="arguments-14"><a class="header" href="#arguments-14"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face"><a class="header" href="#face"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-10"><a class="header" href="#returns-10"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">FVector
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="getcornersws"><a class="header" href="#getcornersws"><strong><code>GetCornersWS</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 97

public:
TArray&lt;FVector&gt; GetCornersWS() const;
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-11"><a class="header" href="#specifiers-11">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Gets the world-space positions of the Lattice corners (including offsets)</p>
  </summary>
<hr />
<h1 id="returns-11"><a class="header" href="#returns-11"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">TArray&lt;FVector&gt;
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="getsourcecornersws"><a class="header" href="#getsourcecornersws"><strong><code>GetSourceCornersWS</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 104

public:
TArray&lt;FVector&gt; GetSourceCornersWS() const;
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-12"><a class="header" href="#specifiers-12">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Gets the world-space positions of the <strong>untransformed</strong> Lattice corners.
i.e. the original/base position based on the input mesh bounds.</p>
  </summary>
<hr />
<h1 id="returns-12"><a class="header" href="#returns-12"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">TArray&lt;FVector&gt;
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="initfromdynamicmesh"><a class="header" href="#initfromdynamicmesh"><strong><code>InitFromDynamicMesh</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 76

public:
bool InitFromDynamicMesh(
    UDynamicMesh* Mesh
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-13"><a class="header" href="#specifiers-13">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Initializes the dynamic mesh from another given dynamic mesh.</p>
  </summary>
<hr />
<h1 id="arguments-15"><a class="header" href="#arguments-15"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="mesh"><a class="header" href="#mesh"><strong><code>Mesh</code></strong></a></h2>
<pre><code class="language-cpp">UDynamicMesh* Mesh
</code></pre>
<p>Mesh to copy</p>
</li>
</ul>
<hr />
<h1 id="returns-13"><a class="header" href="#returns-13"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
<p>True if copying the mesh data was successful, otherwise false</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="initfromskeletalmesh"><a class="header" href="#initfromskeletalmesh"><strong><code>InitFromSkeletalMesh</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 68

public:
bool InitFromSkeletalMesh(
    USkeletalMesh* Mesh
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-14"><a class="header" href="#specifiers-14">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Initializes the dynamic mesh from a given skeletal mesh.</p>
  </summary>
<hr />
<h1 id="arguments-16"><a class="header" href="#arguments-16"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="mesh-1"><a class="header" href="#mesh-1"><strong><code>Mesh</code></strong></a></h2>
<pre><code class="language-cpp">USkeletalMesh* Mesh
</code></pre>
<p>Mesh to copy</p>
</li>
</ul>
<hr />
<h1 id="returns-14"><a class="header" href="#returns-14"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
<p>True if copying the mesh data was successful, otherwise false</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="initfromstaticmesh"><a class="header" href="#initfromstaticmesh"><strong><code>InitFromStaticMesh</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 60

public:
bool InitFromStaticMesh(
    UStaticMesh* Mesh,
    EIncludeCollisionType IncludeCollision = EIncludeCollisionType::NONE
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-15"><a class="header" href="#specifiers-15">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Initializes the dynamic mesh from a given static mesh.</p>
  </summary>
<hr />
<h1 id="arguments-17"><a class="header" href="#arguments-17"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="mesh-2"><a class="header" href="#mesh-2"><strong><code>Mesh</code></strong></a></h2>
<pre><code class="language-cpp">UStaticMesh* Mesh
</code></pre>
<p>Mesh to copy</p>
</li>
<li>
<h2 id="includecollision"><a class="header" href="#includecollision"><strong><code>IncludeCollision</code></strong></a></h2>
<pre><code class="language-cpp">EIncludeCollisionType IncludeCollision = EIncludeCollisionType::NONE
</code></pre>
</li>
</ul>
<hr />
<h1 id="returns-15"><a class="header" href="#returns-15"><strong>Returns</strong></a></h1>
<ul>
<li>
<pre><code class="language-cpp">bool
</code></pre>
<p>True if copying the mesh data was successful, otherwise false</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="onregister"><a class="header" href="#onregister"><strong><code>OnRegister</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 49

public:
virtual void OnRegister() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="posteditchangechainproperty"><a class="header" href="#posteditchangechainproperty"><strong><code>PostEditChangeChainProperty</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 48

public:
virtual void PostEditChangeChainProperty(
    FPropertyChangedChainEvent&amp; PropertyChangedEvent
) override;
</code></pre>
  <details>
<hr />
<h1 id="arguments-18"><a class="header" href="#arguments-18"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="propertychangedevent"><a class="header" href="#propertychangedevent"><strong><code>PropertyChangedEvent</code></strong></a></h2>
<pre><code class="language-cpp">FPropertyChangedChainEvent&amp; PropertyChangedEvent
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="posteditundo"><a class="header" href="#posteditundo"><strong><code>PostEditUndo</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 52

public:
virtual void PostEditUndo() override;
</code></pre>
  <details>
  </details>
</li>
<li>
<h1 id="rotateface"><a class="header" href="#rotateface"><strong><code>RotateFace</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 148

public:
void RotateFace(
    const ELatticeFace Face,
    const FRotator&amp; Rotation
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-16"><a class="header" href="#specifiers-16">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Applies a rotation to one whole side of the lattice, relative to its current
orientatoin, around the centroid of the face vertices.</p>
<p>Calls UpdateMesh.</p>
  </summary>
<hr />
<h1 id="arguments-19"><a class="header" href="#arguments-19"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face-1"><a class="header" href="#face-1"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
<li>
<h2 id="rotation"><a class="header" href="#rotation"><strong><code>Rotation</code></strong></a></h2>
<pre><code class="language-cpp">const FRotator&amp; Rotation
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="scaleface"><a class="header" href="#scaleface"><strong><code>ScaleFace</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 139

public:
void ScaleFace(
    const ELatticeFace Face,
    const FVector&amp; Scale
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-17"><a class="header" href="#specifiers-17">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Scales a face by moving its corners relative to their centroid.</p>
<p>Calls UpdateMesh.</p>
  </summary>
<hr />
<h1 id="arguments-20"><a class="header" href="#arguments-20"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face-2"><a class="header" href="#face-2"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
<li>
<h2 id="scale"><a class="header" href="#scale"><strong><code>Scale</code></strong></a></h2>
<pre><code class="language-cpp">const FVector&amp; Scale
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="setfacetranslation"><a class="header" href="#setfacetranslation"><strong><code>SetFaceTranslation</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 131

public:
void SetFaceTranslation(
    const ELatticeFace Face,
    const FVector&amp; Translation
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-18"><a class="header" href="#specifiers-18">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Sets the translation (absolute movement) of one whole side of the lattice,
relative to the base position of the vertices on that face.</p>
<p>Given translation is expected to be in world space.</p>
<p>Calls UpdateMesh.</p>
  </summary>
<hr />
<h1 id="arguments-21"><a class="header" href="#arguments-21"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face-3"><a class="header" href="#face-3"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
<li>
<h2 id="translation"><a class="header" href="#translation"><strong><code>Translation</code></strong></a></h2>
<pre><code class="language-cpp">const FVector&amp; Translation
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="setlatticews"><a class="header" href="#setlatticews"><strong><code>SetLatticeWS</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 91

public:
void SetLatticeWS(
    TArray&lt;FVector&gt; WSLattice
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-19"><a class="header" href="#specifiers-19">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Sets the lattice corners to the given world-space coordinates.</p>
  </summary>
<hr />
<h1 id="arguments-22"><a class="header" href="#arguments-22"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="wslattice"><a class="header" href="#wslattice"><strong><code>WSLattice</code></strong></a></h2>
<pre><code class="language-cpp">TArray&lt;FVector&gt; WSLattice
</code></pre>
<p>New lattice points, in world-space. Should have length 8.</p>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="translateface"><a class="header" href="#translateface"><strong><code>TranslateFace</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 120

public:
void TranslateFace(
    const ELatticeFace Face,
    const FVector&amp; DeltaTranslation
);
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-20"><a class="header" href="#specifiers-20">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Applies a translation (relative movement) to one whole side of the lattice.</p>
<p>Given translation is expected to be in world space.</p>
<p>Calls UpdateMesh.</p>
  </summary>
<hr />
<h1 id="arguments-23"><a class="header" href="#arguments-23"><strong>Arguments</strong></a></h1>
<ul>
<li>
<h2 id="face-4"><a class="header" href="#face-4"><strong><code>Face</code></strong></a></h2>
<pre><code class="language-cpp">const ELatticeFace Face
</code></pre>
</li>
<li>
<h2 id="deltatranslation"><a class="header" href="#deltatranslation"><strong><code>DeltaTranslation</code></strong></a></h2>
<pre><code class="language-cpp">const FVector&amp; DeltaTranslation
</code></pre>
</li>
</ul>
  </details>
</li>
<li>
<h1 id="updatemesh"><a class="header" href="#updatemesh"><strong><code>UpdateMesh</code></strong></a></h1>
<pre><code class="language-cpp">//  TrilinearInterpolatedMeshComponent.h : 84

public:
void UpdateMesh();
</code></pre>
  <details>
<hr />
<p><strong><em>Reflection-enabled</em></strong></p>
<h3 id="specifiers-21"><a class="header" href="#specifiers-21">Specifiers:</a></h3>
<ul>
<li><strong>BlueprintCallable</strong></li>
<li><strong>Category</strong> = <em>NBTrilinearInterpolation</em></li>
</ul>
  <summary>
<p>Updates the underlying mesh data to match the current Lattice configuration.</p>
<p>Should be called whenever Lattice has been modified to keep the mesh up-to-date.</p>
  </summary>
  </details>
</li>
</ul>
<p><br/><br/>
<br/><br/></p>
<hr />
<blockquote>
<p>For any questions, help, suggestions or feature requests, please feel free to contact me at <a href="mailto:nbpsup@gmail.com">nbpsup@gmail.com</a></p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
